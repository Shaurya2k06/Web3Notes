# Proof of Work for Dummies

The first step of mining a block is to take pending transactions from the memory pool and submit them, one by one, through a hash function. Each time a piece of data is run through a hash function, an output of fixed size called a hash is generated.

After each transaction is hashed, the hashes are organized into what is called a Merkle tree (also known as a hash tree). A Merkle tree is generated by organizing transaction hashes into pairs and then hashing them. The new hash outputs are then organized into pairs and hashed again, and the process is repeated until a single hash is created. This last hash is known as the root hash (or Merkle root) and is basically the hash that represents all the previous hashes used to generate it.

A block header acts as an identifier for each individual block, meaning each block has a unique hash. When creating a new block, miners combine the hash of the previous block with the root hash of their candidate block to generate a new block hash. They must also add an arbitrary number known as a nonce.

So, when trying to confirm their candidate block, a miner needs to combine the root hash, the previous block’s hash, and a nonce and put them all through a hash function. Their goal is to do this repeatedly until they can create a valid hash. As we’ve seen, miners must hash the block header repeatedly using different nonce values. They do so until they find a valid block hash. When a miner finds a valid block hash, they broadcast this block to the network. Then, all other validating nodes will check if the block is valid and, if so, add the new block to their copy of the blockchain.

## Additional Information

- **Hash Function**: A function that converts an input (or 'message') into a fixed-length string of bytes. The output is typically a 'digest' that is unique to each unique input.
- **Nonce**: An arbitrary number that can only be used once in a cryptographic communication. It is often a random or pseudo-random number issued in an authentication protocol to ensure that old communications cannot be reused in replay attacks.
- **Merkle Tree**: A tree in which every leaf node is labeled with the cryptographic hash of a data block, and every non-leaf node is labeled with the cryptographic hash of the labels of its child nodes. Merkle trees allow efficient and secure verification of the contents of large data structures.
- **Block Header**: A summary of the contents of a block, including metadata such as the previous block hash, the Merkle root, and a timestamp.