# DeFi Security and Common Vulnerabilities

## Overview

DeFi security is paramount as smart contracts handle billions of dollars with immutable code. Understanding common vulnerabilities and security best practices is essential for developers and users.

## Common Vulnerabilities

### 1. Reentrancy Attacks

**Description:** Attacker recursively calls a function before the first invocation completes.

**Vulnerable Code:**
```solidity
function withdraw(uint256 amount) external {
    require(balances[msg.sender] >= amount);
    
    // VULNERABLE: External call before state update
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
    
    balances[msg.sender] -= amount;
}
```

**Attack:**
```solidity
contract Attacker {
    Victim victim;
    
    function attack() external payable {
        victim.deposit{value: 1 ether}();
        victim.withdraw(1 ether);
    }
    
    receive() external payable {
        if (address(victim).balance >= 1 ether) {
            victim.withdraw(1 ether); // Reenter!
        }
    }
}
```

**Fix: Checks-Effects-Interactions**
```solidity
function withdraw(uint256 amount) external {
    require(balances[msg.sender] >= amount);
    
    // Update state BEFORE external call
    balances[msg.sender] -= amount;
    
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
}
```


**Fix: ReentrancyGuard**
```solidity
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract Secure is ReentrancyGuard {
    mapping(address => uint256) public balances;
    
    function withdraw(uint256 amount) external nonReentrant {
        require(balances[msg.sender] >= amount);
        balances[msg.sender] -= amount;
        
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success);
    }
}
```

**Famous Attack: The DAO (2016)**
```
Loss: $60 million (3.6M ETH)
Method: Recursive withdrawal
Impact: Ethereum hard fork (ETH/ETC split)
```

### 2. Oracle Manipulation

**Description:** Attackers manipulate price feeds to exploit protocols.

**Attack Vector:**
```
1. Flash loan large amount
2. Drain AMM pool to manipulate price
3. Protocol reads manipulated price
4. Borrow maximum against inflated collateral
5. Repay flash loan
6. Keep borrowed funds
```

**Vulnerable Code:**
```solidity
function getPrice() public view returns (uint256) {
    // VULNERABLE: Spot price from single AMM
    uint256 ethReserve = pair.reserve0();
    uint256 usdcReserve = pair.reserve1();
    return usdcReserve / ethReserve;
}
```

**Attack Example:**
```
Normal Pool State:
- 1000 ETH
- 2,000,000 USDC
- Price: $2,000/ETH

Attacker:
1. Flash loan 10,000 ETH
2. Sell all ETH in pool
3. Pool now: 11,000 ETH, 181,818 USDC
4. Manipulated price: $16.53/ETH
5. Protocol thinks ETH crashed
6. Liquidate positions at fake price
7. Profit from liquidations
```

**Fix: Time-Weighted Average Price (TWAP)**
```solidity
contract SecureOracle {
    uint256 public price0CumulativeLast;
    uint256 public blockTimestampLast;
    uint256 public priceAverage;
    
    function update() external {
        (uint256 price0Cumulative, , uint256 blockTimestamp) = 
            UniswapV2OracleLibrary.currentCumulativePrices(pair);
        
        uint256 timeElapsed = blockTimestamp - blockTimestampLast;
        
        if (timeElapsed >= PERIOD) {
            priceAverage = (price0Cumulative - price0CumulativeLast) / timeElapsed;
            price0CumulativeLast = price0Cumulative;
            blockTimestampLast = blockTimestamp;
        }
    }
}
```

**Fix: Chainlink Oracles**
```solidity
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract ChainlinkPriceConsumer {
    AggregatorV3Interface internal priceFeed;
    
    constructor() {
        priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
    }
    
    function getLatestPrice() public view returns (int) {
        (
            uint80 roundID,
            int price,
            uint startedAt,
            uint timeStamp,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        
        require(timeStamp > 0, "Round not complete");
        require(answeredInRound >= roundID, "Stale price");
        
        return price;
    }
}
```

**Famous Attacks:**

**Harvest Finance (Oct 2020):**
```
Loss: $34 million
Method: Curve pool price manipulation
Attack: Flash loan → manipulate → arbitrage
```

**Cream Finance (Oct 2021):**
```
Loss: $130 million
Method: Price oracle manipulation
Attack: Flash loan → inflate collateral → borrow
```

### 3. Flash Loan Attacks

**Description:** Using flash loans to exploit protocol vulnerabilities.

**Common Patterns:**
1. Price manipulation
2. Governance attacks
3. Arbitrage exploitation
4. Liquidation manipulation

**Governance Attack Example:**
```
1. Flash loan 1M governance tokens
2. Create malicious proposal
3. Vote with borrowed tokens
4. Execute immediately (if no timelock)
5. Drain protocol
6. Repay flash loan
```

**Mitigation:**
- Snapshot voting (past balances)
- Voting delays
- Timelocks on execution
- Minimum holding periods
- Quorum requirements

### 4. Front-Running and MEV

**Description:** Bots observe pending transactions and profit by reordering.

**Sandwich Attack:**
```
User's Transaction (in mempool):
- Swap 100 ETH for USDC on Uniswap

Bot's Attack:
1. Front-run: Buy USDC (raises price)
2. User's swap executes (worse price)
3. Back-run: Sell USDC (profit from price increase)

User loses: $5,000
Bot profits: $5,000
```

**MEV Extraction:**
```
Block Builder sees:
- Arbitrage opportunity: $10,000 profit
- User's transaction: $8,000 profit
- Liquidation: $5,000 profit

Builder orders transactions to maximize MEV
Total extracted: $23,000
```

**Mitigation:**
- Private transactions (Flashbots Protect)
- MEV-resistant DEXs (CoW Protocol)
- Slippage protection
- Limit orders instead of market orders

### 5. Access Control Vulnerabilities

**Description:** Improper permission management allows unauthorized actions.

**Vulnerable Code:**
```solidity
contract Vulnerable {
    address public owner;
    
    function withdraw() external {
        // VULNERABLE: No access control!
        payable(msg.sender).transfer(address(this).balance);
    }
}
```

**Fix:**
```solidity
import "@openzeppelin/contracts/access/Ownable.sol";

contract Secure is Ownable {
    function withdraw() external onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }
    
    function emergencyWithdraw() external onlyOwner {
        // Additional safety checks
        require(block.timestamp > lastWithdraw + 1 days, "Too soon");
        lastWithdraw = block.timestamp;
        payable(owner()).transfer(address(this).balance);
    }
}
```

**Role-Based Access Control:**
```solidity
import "@openzeppelin/contracts/access/AccessControl.sol";

contract MultiRole is AccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");
    
    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);
    }
    
    function criticalFunction() external onlyRole(ADMIN_ROLE) {
        // Only admins can call
    }
    
    function operatorFunction() external onlyRole(OPERATOR_ROLE) {
        // Only operators can call
    }
}
```

**Famous Attack: Poly Network (2021):**
```
Loss: $611 million
Vulnerability: Missing access control on cross-chain message verification
Method: Called privileged function without authorization
Outcome: Hacker returned funds (white hat)
```

### 6. Integer Overflow/Underflow

**Description:** Arithmetic operations exceed variable limits.

**Vulnerable Code (Solidity < 0.8.0):**
```solidity
contract Vulnerable {
    mapping(address => uint256) public balances;
    
    function withdraw(uint256 amount) external {
        // VULNERABLE: Underflow possible
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }
}
```

**Attack:**
```
Balance: 100
Withdraw: 200
Result: 100 - 200 = 2^256 - 100 (massive number!)
```

**Fix (Solidity >= 0.8.0):**
```solidity
// Automatic overflow/underflow checks
contract Secure {
    mapping(address => uint256) public balances;
    
    function withdraw(uint256 amount) external {
        balances[msg.sender] -= amount; // Reverts on underflow
        payable(msg.sender).transfer(amount);
    }
}
```

**Fix (Solidity < 0.8.0):**
```solidity
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract Secure {
    using SafeMath for uint256;
    mapping(address => uint256) public balances;
    
    function withdraw(uint256 amount) external {
        balances[msg.sender] = balances[msg.sender].sub(amount);
        payable(msg.sender).transfer(amount);
    }
}
```

### 7. Denial of Service (DoS)

**Description:** Attacks that prevent legitimate users from using the protocol.

**Gas Limit DoS:**
```solidity
contract Vulnerable {
    address[] public users;
    
    function distributeRewards() external {
        // VULNERABLE: Unbounded loop
        for (uint i = 0; i < users.length; i++) {
            payable(users[i]).transfer(reward);
        }
    }
}
```

**Attack:**
```
1. Attacker creates 10,000 accounts
2. Each account deposits minimum amount
3. users.length = 10,000
4. distributeRewards() exceeds gas limit
5. Function becomes unusable
```

**Fix: Pull Over Push**
```solidity
contract Secure {
    mapping(address => uint256) public rewards;
    
    function claimReward() external {
        uint256 reward = rewards[msg.sender];
        rewards[msg.sender] = 0;
        payable(msg.sender).transfer(reward);
    }
}
```

**Revert DoS:**
```solidity
contract Vulnerable {
    address public currentLeader;
    uint256 public highestBid;
    
    function bid() external payable {
        require(msg.value > highestBid);
        
        // VULNERABLE: Refund can fail
        payable(currentLeader).transfer(highestBid);
        
        currentLeader = msg.sender;
        highestBid = msg.value;
    }
}
```

**Attack:**
```solidity
contract Attacker {
    function attack(address victim) external payable {
        Vulnerable(victim).bid{value: msg.value}();
    }
    
    // Reject refunds
    receive() external payable {
        revert();
    }
}
```

**Fix:**
```solidity
contract Secure {
    mapping(address => uint256) public pendingReturns;
    
    function bid() external payable {
        require(msg.value > highestBid);
        
        // Store refund instead of sending
        pendingReturns[currentLeader] += highestBid;
        
        currentLeader = msg.sender;
        highestBid = msg.value;
    }
    
    function withdraw() external {
        uint256 amount = pendingReturns[msg.sender];
        pendingReturns[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
    }
}
```

### 8. Signature Replay Attacks

**Description:** Reusing valid signatures in unintended contexts.

**Vulnerable Code:**
```solidity
contract Vulnerable {
    function executeWithSignature(
        address to,
        uint256 amount,
        bytes memory signature
    ) external {
        bytes32 hash = keccak256(abi.encodePacked(to, amount));
        address signer = recoverSigner(hash, signature);
        
        // VULNERABLE: No nonce or expiry
        require(signer == owner, "Invalid signature");
        payable(to).transfer(amount);
    }
}
```

**Attack:**
```
1. Owner signs: transfer 1 ETH to Alice
2. Transaction executes
3. Attacker captures signature
4. Replays signature multiple times
5. Drains contract
```

**Fix: Nonce and Expiry**
```solidity
contract Secure {
    mapping(address => uint256) public nonces;
    
    function executeWithSignature(
        address to,
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        bytes memory signature
    ) external {
        require(block.timestamp <= expiry, "Signature expired");
        require(nonce == nonces[msg.sender], "Invalid nonce");
        
        bytes32 hash = keccak256(abi.encodePacked(
            to,
            amount,
            nonce,
            expiry,
            address(this), // Prevent cross-contract replay
            block.chainid  // Prevent cross-chain replay
        ));
        
        address signer = recoverSigner(hash, signature);
        require(signer == owner, "Invalid signature");
        
        nonces[msg.sender]++;
        payable(to).transfer(amount);
    }
}
```

**Famous Attack: Wormhole (2022):**
```
Loss: $325 million
Vulnerability: Signature verification bypass
Method: Forged guardian signatures
Impact: Minted 120,000 ETH on Solana
```

### 9. Delegate Call Vulnerabilities

**Description:** `delegatecall` executes code in caller's context, risking storage corruption.

**Vulnerable Code:**
```solidity
contract Vulnerable {
    address public owner;
    address public implementation;
    
    function upgrade(address newImplementation) external {
        // VULNERABLE: Anyone can call
        implementation = newImplementation;
    }
    
    fallback() external payable {
        address impl = implementation;
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
}
```

**Attack:**
```solidity
contract Malicious {
    address public owner; // Same storage slot as Vulnerable
    
    function pwn() external {
        owner = msg.sender; // Overwrites Vulnerable.owner!
    }
}
```

**Fix:**
```solidity
import "@openzeppelin/contracts/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol";

contract Secure is Initializable, UUPSUpgradeable {
    address public owner;
    
    function initialize() public initializer {
        owner = msg.sender;
    }
    
    function _authorizeUpgrade(address newImplementation) 
        internal 
        override 
        onlyOwner 
    {}
}
```

### 10. Unchecked External Calls

**Description:** Not checking return values of external calls.

**Vulnerable Code:**
```solidity
contract Vulnerable {
    function withdraw(address token, uint256 amount) external {
        // VULNERABLE: Doesn't check return value
        IERC20(token).transfer(msg.sender, amount);
    }
}
```

**Problem:**
```
Some tokens (e.g., USDT) don't return bool
Some tokens return false on failure instead of reverting
Silent failures can lead to accounting errors
```

**Fix:**
```solidity
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract Secure {
    using SafeERC20 for IERC20;
    
    function withdraw(address token, uint256 amount) external {
        IERC20(token).safeTransfer(msg.sender, amount);
    }
}
```

## Security Best Practices

### 1. Development Practices

**Use Established Libraries:**
```solidity
// Good: Use OpenZeppelin
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract MyToken is ERC20, Ownable, ReentrancyGuard {
    // Implementation
}
```

**Follow Checks-Effects-Interactions:**
```solidity
function withdraw(uint256 amount) external {
    // 1. Checks
    require(balances[msg.sender] >= amount, "Insufficient balance");
    require(amount > 0, "Amount must be positive");
    
    // 2. Effects
    balances[msg.sender] -= amount;
    totalSupply -= amount;
    
    // 3. Interactions
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success, "Transfer failed");
}
```

**Use Modifiers for Access Control:**
```solidity
modifier onlyOwner() {
    require(msg.sender == owner, "Not owner");
    _;
}

modifier validAmount(uint256 amount) {
    require(amount > 0, "Invalid amount");
    require(amount <= maxAmount, "Exceeds maximum");
    _;
}

function criticalFunction(uint256 amount) 
    external 
    onlyOwner 
    validAmount(amount) 
{
    // Implementation
}
```

### 2. Testing Practices

**Unit Tests:**
```javascript
describe("Token", function() {
    it("Should transfer tokens correctly", async function() {
        const [owner, addr1] = await ethers.getSigners();
        const Token = await ethers.getContractFactory("MyToken");
        const token = await Token.deploy();
        
        await token.transfer(addr1.address, 100);
        expect(await token.balanceOf(addr1.address)).to.equal(100);
    });
    
    it("Should prevent unauthorized transfers", async function() {
        await expect(
            token.connect(addr1).transferFrom(owner.address, addr1.address, 100)
        ).to.be.revertedWith("Insufficient allowance");
    });
});
```

**Fuzzing:**
```javascript
const { ethers } = require("hardhat");
const { expect } = require("chai");

describe("Fuzz Testing", function() {
    it("Should handle random inputs", async function() {
        for (let i = 0; i < 1000; i++) {
            const randomAmount = Math.floor(Math.random() * 1000000);
            const randomAddress = ethers.Wallet.createRandom().address;
            
            // Test with random inputs
            try {
                await token.transfer(randomAddress, randomAmount);
            } catch (error) {
                // Should revert gracefully
                expect(error.message).to.include("revert");
            }
        }
    });
});
```

**Mainnet Forking:**
```javascript
describe("Mainnet Fork Tests", function() {
    before(async function() {
        await network.provider.request({
            method: "hardhat_reset",
            params: [{
                forking: {
                    jsonRpcUrl: process.env.MAINNET_RPC,
                    blockNumber: 15000000
                }
            }]
        });
    });
    
    it("Should interact with real protocols", async function() {
        const uniswap = await ethers.getContractAt("IUniswapV2Router", UNISWAP_ROUTER);
        // Test real interactions
    });
});
```

### 3. Audit Checklist

**Pre-Audit:**
- [ ] All functions have NatSpec comments
- [ ] Test coverage > 90%
- [ ] No compiler warnings
- [ ] Slither analysis passed
- [ ] Mythril analysis passed
- [ ] Manual code review completed

**Audit Focus Areas:**
- [ ] Access control on all privileged functions
- [ ] Reentrancy protection where needed
- [ ] Integer overflow/underflow checks
- [ ] External call return values checked
- [ ] Oracle manipulation resistance
- [ ] Flash loan attack resistance
- [ ] Gas optimization
- [ ] Upgrade mechanism security

**Post-Audit:**
- [ ] All critical issues resolved
- [ ] All high issues resolved
- [ ] Medium issues addressed or documented
- [ ] Bug bounty program launched
- [ ] Monitoring and alerting set up

### 4. Monitoring and Response

**On-Chain Monitoring:**
```javascript
// Monitor for suspicious transactions
const provider = new ethers.providers.WebSocketProvider(WS_URL);

contract.on("Transfer", (from, to, amount, event) => {
    if (amount > LARGE_AMOUNT_THRESHOLD) {
        alert(`Large transfer: ${amount} from ${from} to ${to}`);
    }
});

contract.on("Withdrawal", (user, amount, event) => {
    if (isBlacklisted(user)) {
        alert(`Blacklisted user withdrawal: ${user}`);
    }
});
```

**Circuit Breakers:**
```solidity
contract CircuitBreaker {
    bool public paused;
    address public guardian;
    
    modifier whenNotPaused() {
        require(!paused, "Contract paused");
        _;
    }
    
    function pause() external {
        require(msg.sender == guardian, "Not guardian");
        paused = true;
        emit Paused(block.timestamp);
    }
    
    function unpause() external {
        require(msg.sender == guardian, "Not guardian");
        require(block.timestamp > pausedAt + 24 hours, "Too soon");
        paused = false;
        emit Unpaused(block.timestamp);
    }
}
```

**Rate Limiting:**
```solidity
contract RateLimited {
    mapping(address => uint256) public lastAction;
    mapping(address => uint256) public actionCount;
    uint256 public constant RATE_LIMIT = 10; // 10 actions per hour
    
    modifier rateLimit() {
        if (block.timestamp > lastAction[msg.sender] + 1 hours) {
            actionCount[msg.sender] = 0;
            lastAction[msg.sender] = block.timestamp;
        }
        
        require(actionCount[msg.sender] < RATE_LIMIT, "Rate limit exceeded");
        actionCount[msg.sender]++;
        _;
    }
    
    function sensitiveAction() external rateLimit {
        // Implementation
    }
}
```

## Security Tools

### Static Analysis

**Slither:**
```bash
pip install slither-analyzer
slither . --detect reentrancy-eth,reentrancy-no-eth,reentrancy-benign
```

**Mythril:**
```bash
pip install mythril
myth analyze contracts/MyContract.sol
```

**Manticore:**
```bash
pip install manticore
manticore contracts/MyContract.sol
```

### Formal Verification

**Certora:**
```
// Specify invariants
invariant totalSupplyEqualsBalances()
    totalSupply == sum(balances)
```

**K Framework:**
```k
rule transfer-success:
    <k> transfer(To, Amount) => . ... </k>
    <balance> Sender |-> (BalS => BalS - Amount) </balance>
    <balance> To |-> (BalT => BalT + Amount) </balance>
    requires BalS >= Amount
```

### Runtime Monitoring

**Forta:**
```javascript
// Bot to detect suspicious activity
const { Finding, FindingSeverity, FindingType } = require("forta-agent");

async function handleTransaction(txEvent) {
    const findings = [];
    
    // Check for large withdrawals
    const withdrawals = txEvent.filterLog(WITHDRAWAL_EVENT);
    for (const withdrawal of withdrawals) {
        if (withdrawal.args.amount > THRESHOLD) {
            findings.push(Finding.fromObject({
                name: "Large Withdrawal Detected",
                description: `Withdrawal of ${withdrawal.args.amount}`,
                alertId: "LARGE-WITHDRAWAL",
                severity: FindingSeverity.High,
                type: FindingType.Suspicious
            }));
        }
    }
    
    return findings;
}
```

## Incident Response

### Response Plan

**1. Detection:**
```
- Monitoring alerts trigger
- Community reports issue
- Unusual on-chain activity
```

**2. Assessment:**
```
- Determine severity
- Identify affected contracts
- Estimate potential loss
- Check if exploit is ongoing
```

**3. Containment:**
```
- Pause affected contracts
- Revoke approvals
- Block malicious addresses
- Coordinate with other protocols
```

**4. Resolution:**
```
- Deploy fixes
- Recover funds if possible
- Compensate affected users
- Resume operations
```

**5. Post-Mortem:**
```
- Document incident
- Identify root cause
- Implement preventive measures
- Update security practices
```

### Emergency Contacts

**White Hat Groups:**
- Samczsun
- BlockSec
- PeckShield
- Immunefi

**Exchanges:**
- Binance Security
- Coinbase Security
- Kraken Security

**Infrastructure:**
- Flashbots
- Chainlink
- Circle (USDC)

## Conclusion

DeFi security requires constant vigilance, thorough testing, and defense-in-depth strategies. Understanding common vulnerabilities and implementing best practices is essential for building secure protocols. Remember: code is law, and bugs are permanent once deployed.

---

*Next: Governance*
