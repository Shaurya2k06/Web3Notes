# DeFi Security and Common Vulnerabilities

## Overview

DeFi security is paramount as smart contracts handle billions of dollars with immutable code. Understanding common vulnerabilities and security best practices is essential for developers and users.

## Common Vulnerabilities

### 1. Reentrancy Attacks

**Description:** Attacker recursively calls a function before the first invocation completes.

**Vulnerable Code:**
```solidity
function withdraw(uint256 amount) external {
    require(balances[msg.sender] >= amount);
    
    // VULNERABLE: External call before state update
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
    
    balances[msg.sender] -= amount;
}
```

**Attack:**
```solidity
contract Attacker {
    Victim victim;
    
    function attack() external payable {
        victim.deposit{value: 1 ether}();
        victim.withdraw(1 ether);
    }
    
    receive() external payable {
        if (address(victim).balance >= 1 ether) {
            victim.withdraw(1 ether); // Reenter!
        }
    }
}
```

**Fix: Checks-Effects-Interactions**
```solidity
function withdraw(uint256 amount) external {
    require(balances[msg.sender] >= amount);
    
    // Update state BEFORE external call
    balances[msg.sender] -= amount;
    
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
}
```

