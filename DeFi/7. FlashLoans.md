# Flash Loans

## Overview

Flash loans are uncollateralized loans that must be borrowed and repaid within a single blockchain transaction. They represent a unique DeFi primitive impossible in traditional finance.

## How Flash Loans Work

### Basic Mechanism

```
1. Borrow assets (no collateral required)
2. Execute arbitrary operations
3. Repay loan + fee
4. If repayment fails, entire transaction reverts
```

**Atomicity:** All operations succeed or fail together.

### Transaction Flow

```solidity
function executeFlashLoan() external {
    // 1. Request flash loan
    lendingPool.flashLoan(
        address(this),
        assets,
        amounts,
        modes,
        onBehalfOf,
        params,
        referralCode
    );
}

function executeOperation(
    address[] calldata assets,
    uint256[] calldata amounts,
    uint256[] calldata premiums,
    address initiator,
    bytes calldata params
) external returns (bool) {
    // 2. Use borrowed funds
    // ... your logic here ...
    
    // 3. Approve repayment
    for (uint i = 0; i < assets.length; i++) {
        uint amountOwing = amounts[i] + premiums[i];
        IERC20(assets[i]).approve(address(lendingPool), amountOwing);
    }
    
    return true;
}
```


## Flash Loan Providers

### Aave

**Specifications:**
```
Fee: 0.09% of borrowed amount
Max Amount: Pool liquidity
Assets: 30+ tokens
Chains: Ethereum, Polygon, Avalanche, Arbitrum, Optimism
```

**Example:**
```
Borrow: 1,000 ETH
Fee: 0.9 ETH
Must repay: 1,000.9 ETH in same transaction
```

### dYdX

**Specifications:**
```
Fee: 0% (free flash loans)
Max Amount: Pool liquidity
Assets: ETH, USDC, DAI
Limitation: Must use dYdX protocol
```

### Balancer

**Specifications:**
```
Fee: Varies by pool (typically 0%)
Max Amount: Entire pool balance
Assets: Any token in Balancer pools
Unique: Can borrow multiple assets simultaneously
```

## Use Cases

### 1. Arbitrage

Exploit price differences across DEXs:

**Example:**
```
ETH on Uniswap: $2,000
ETH on Sushiswap: $2,010

Flash Loan Strategy:
1. Borrow 1,000 ETH from Aave
2. Sell on Sushiswap: 1,000 ETH → $2,010,000
3. Buy on Uniswap: $2,010,000 → 1,005 ETH
4. Repay 1,000.9 ETH to Aave
5. Profit: 4.1 ETH ($8,200)

Gas costs: ~$500
Net profit: ~$7,700
```

**Code Example:**
```solidity
function executeArbitrage() external {
    uint256 amount = 1000 ether;
    
    // 1. Flash loan 1000 ETH
    aave.flashLoan(address(this), ETH, amount, data);
}

function executeOperation(
    address asset,
    uint256 amount,
    uint256 premium,
    address initiator,
    bytes calldata params
) external returns (bool) {
    // 2. Sell on Sushiswap
    uint256 usdcReceived = sushiswap.swapExactTokensForTokens(
        amount,
        minUSDC,
        pathETHtoUSDC,
        address(this),
        deadline
    );
    
    // 3. Buy on Uniswap
    uint256 ethReceived = uniswap.swapExactTokensForTokens(
        usdcReceived,
        minETH,
        pathUSDCtoETH,
        address(this),
        deadline
    );
    
    // 4. Approve repayment
    uint256 amountOwed = amount + premium;
    IERC20(asset).approve(address(aave), amountOwed);
    
    // 5. Keep profit
    uint256 profit = ethReceived - amountOwed;
    
    return true;
}
```

### 2. Collateral Swap

Change collateral without closing position:

**Scenario:**
```
Current: 100 ETH collateral, 50,000 USDC debt on Aave
Goal: Swap to WBTC collateral

Traditional Method:
1. Deposit 50,000 USDC
2. Repay debt
3. Withdraw 100 ETH
4. Buy WBTC
5. Deposit WBTC
6. Borrow 50,000 USDC
Problem: Need 50,000 USDC upfront

Flash Loan Method:
1. Flash loan 50,000 USDC
2. Repay debt
3. Withdraw 100 ETH
4. Swap ETH → WBTC
5. Deposit WBTC
6. Borrow 50,000 USDC
7. Repay flash loan
Result: No upfront capital needed
```

**Code:**
```solidity
function swapCollateral() external {
    // Flash loan USDC to repay debt
    aave.flashLoan(address(this), USDC, 50000e6, data);
}

function executeOperation(...) external returns (bool) {
    // 1. Repay USDC debt
    aave.repay(USDC, 50000e6, 2, address(this));
    
    // 2. Withdraw ETH collateral
    aave.withdraw(ETH, 100 ether, address(this));
    
    // 3. Swap ETH to WBTC
    uint256 wbtcAmount = uniswap.swapExactTokensForTokens(
        100 ether,
        minWBTC,
        pathETHtoWBTC,
        address(this),
        deadline
    );
    
    // 4. Deposit WBTC as collateral
    aave.deposit(WBTC, wbtcAmount, address(this), 0);
    
    // 5. Borrow USDC to repay flash loan
    aave.borrow(USDC, 50000e6, 2, 0, address(this));
    
    // 6. Approve flash loan repayment
    IERC20(USDC).approve(address(aave), 50000e6 + premium);
    
    return true;
}
```

### 3. Self-Liquidation

Liquidate your own position to avoid liquidation penalty:

**Scenario:**
```
Position: 100 ETH collateral, 60,000 USDC debt
Health Factor: 1.05 (near liquidation)
Liquidation Penalty: 10%

Normal Liquidation:
- Lose 10% of collateral ($20,000)

Self-Liquidation:
1. Flash loan 60,000 USDC
2. Repay debt
3. Withdraw all collateral
4. Sell enough ETH to repay flash loan
5. Keep remaining ETH
Savings: ~$20,000 (minus gas)
```

### 4. Leverage in One Transaction

Open leveraged position instantly:

**Example: 5x Long ETH**
```
Capital: $10,000

Strategy:
1. Flash loan $40,000 USDC
2. Buy ETH with $50,000 total
3. Deposit ETH as collateral
4. Borrow $40,000 USDC
5. Repay flash loan

Result: $50,000 ETH exposure with $10,000 capital (5x leverage)
```

### 5. Debt Refinancing

Move debt to protocol with better rates:

**Scenario:**
```
Current: 50,000 USDC debt on Compound (8% APY)
Target: Move to Aave (5% APY)

Flash Loan Method:
1. Flash loan 50,000 USDC
2. Repay Compound debt
3. Withdraw collateral from Compound
4. Deposit collateral to Aave
5. Borrow 50,000 USDC from Aave
6. Repay flash loan

Savings: 3% APY = $1,500/year
```

## Attack Vectors

### 1. Oracle Manipulation

**Attack Flow:**
```
1. Flash loan large amount
2. Manipulate price oracle (drain AMM pool)
3. Borrow maximum against inflated collateral
4. Repay flash loan
5. Keep borrowed funds
6. Oracle corrects, protocol left with bad debt
```

**Example: Harvest Finance (Oct 2020)**
```
Loss: $34 million
Method:
1. Flash loan USDC and USDT
2. Manipulate Curve pool prices
3. Exploit arbitrage in fUSDT vault
4. Drain funds
5. Repay flash loan
```

**Mitigation:**
- Use time-weighted average prices (TWAP)
- Multiple oracle sources
- Manipulation-resistant oracles (Chainlink)
- Liquidity depth checks

### 2. Reentrancy Attacks

**Attack Flow:**
```
1. Flash loan tokens
2. Call vulnerable function
3. Reenter contract before state update
4. Drain funds
5. Repay flash loan
```

**Example: Cream Finance (Aug 2021)**
```
Loss: $18.8 million
Method:
1. Flash loan ETH
2. Exploit reentrancy in AMP token
3. Borrow against inflated collateral
4. Repay flash loan
```

**Mitigation:**
- Checks-Effects-Interactions pattern
- Reentrancy guards
- Pull over push payments

### 3. Flash Loan + Governance Attack

**Attack Flow:**
```
1. Flash loan governance tokens
2. Vote on malicious proposal
3. Execute proposal immediately
4. Drain protocol
5. Repay flash loan
```

**Mitigation:**
- Time delays on governance
- Snapshot voting (past balances)
- Minimum holding periods
- Quorum requirements

## Flash Loan Economics

### Profitability Calculation

```
Profit = Revenue - Costs

Revenue = Arbitrage Gain or Exploit Proceeds

Costs:
- Flash loan fee (0.09% typically)
- Gas fees ($50 - $500+)
- Slippage
- MEV bot competition
```

**Break-Even Analysis:**
```
Minimum Profit = (Loan Amount × Fee %) + Gas Costs

Example:
Loan: $1,000,000
Fee: 0.09% = $900
Gas: $200
Minimum Profit: $1,100

Required Arbitrage: > 0.11%
```

### MEV and Flash Loans

Maximal Extractable Value (MEV) bots compete for flash loan opportunities:

**Competition:**
```
1. Bot A sees arbitrage opportunity
2. Bot B sees same opportunity
3. Both submit transactions
4. Gas war ensues
5. Winner pays high gas, loser wastes gas
6. Profit margins compressed
```

**Flashbots:**
Private transaction pool to avoid gas wars:
```
- Submit bundle of transactions
- Miners include bundle or reject entirely
- No failed transaction costs
- More efficient MEV extraction
```

## Advanced Flash Loan Patterns

### 1. Multi-Hop Arbitrage

Arbitrage across multiple DEXs:

```
1. Flash loan ETH
2. ETH → USDC on Uniswap
3. USDC → DAI on Curve
4. DAI → USDT on Balancer
5. USDT → ETH on Sushiswap
6. Repay flash loan
7. Keep profit
```

### 2. Triangular Arbitrage

Exploit price discrepancies in three-way pairs:

```
1. Flash loan ETH
2. ETH → USDC (Uniswap)
3. USDC → DAI (Curve)
4. DAI → ETH (Sushiswap)
5. Repay flash loan

Profit if: (1/P₁) × (1/P₂) × (1/P₃) > 1
```

### 3. Liquidation Hunting

Use flash loans to liquidate positions:

```
1. Monitor positions near liquidation
2. Flash loan repayment token
3. Liquidate position
4. Receive collateral + bonus
5. Sell collateral
6. Repay flash loan
7. Keep profit (liquidation bonus - fees)
```

### 4. Yield Optimization

Compound rewards across protocols:

```
1. Flash loan large amount
2. Deposit to protocol
3. Claim rewards (proportional to deposit)
4. Withdraw
5. Repay flash loan
6. Keep rewards

Note: Most protocols have countermeasures
```

## Security Best Practices

### For Flash Loan Users

1. **Test thoroughly:** Use testnets first
2. **Calculate gas:** Ensure profitability after gas
3. **Handle failures:** Proper error handling
4. **Slippage protection:** Set minimum outputs
5. **Time sensitivity:** Account for block time
6. **Reentrancy guards:** Protect your contract

### For Protocol Developers

1. **Oracle security:**
   - Use TWAP oracles
   - Multiple price sources
   - Manipulation checks

2. **Access controls:**
   - Proper authorization
   - Time locks
   - Admin key security

3. **State management:**
   - Checks-Effects-Interactions
   - Reentrancy guards
   - Atomic operations

4. **Rate limiting:**
   - Borrow caps
   - Velocity limits
   - Circuit breakers

## Code Example: Complete Flash Loan

```solidity
pragma solidity ^0.8.0;

import "@aave/core-v3/contracts/flashloan/base/FlashLoanSimpleReceiverBase.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract FlashLoanArbitrage is FlashLoanSimpleReceiverBase {
    address private immutable owner;
    
    constructor(address _addressProvider) 
        FlashLoanSimpleReceiverBase(IPoolAddressesProvider(_addressProvider)) 
    {
        owner = msg.sender;
    }
    
    function executeFlashLoan(
        address asset,
        uint256 amount
    ) external {
        require(msg.sender == owner, "Only owner");
        
        bytes memory params = abi.encode(msg.sender);
        
        POOL.flashLoanSimple(
            address(this),
            asset,
            amount,
            params,
            0
        );
    }
    
    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address initiator,
        bytes calldata params
    ) external override returns (bool) {
        require(msg.sender == address(POOL), "Only pool");
        require(initiator == address(this), "Only this contract");
        
        // YOUR ARBITRAGE LOGIC HERE
        // Example: Swap on DEX A, swap back on DEX B
        
        uint256 profit = performArbitrage(asset, amount);
        
        // Approve repayment
        uint256 amountOwed = amount + premium;
        require(profit > premium, "Not profitable");
        
        IERC20(asset).approve(address(POOL), amountOwed);
        
        // Transfer profit to owner
        IERC20(asset).transfer(owner, profit - premium);
        
        return true;
    }
    
    function performArbitrage(
        address asset,
        uint256 amount
    ) internal returns (uint256) {
        // Implement your arbitrage strategy
        // This is a placeholder
        return amount + 1000; // Simulated profit
    }
    
    receive() external payable {}
}
```

## Monitoring and Tools

### Flash Loan Monitoring

**Platforms:**
- Dune Analytics: Flash loan dashboards
- Etherscan: Transaction tracking
- Tenderly: Simulation and debugging
- Flashbots: MEV monitoring

### Development Tools

**Testing:**
```javascript
// Hardhat flash loan test
it("Should execute profitable arbitrage", async function() {
    const flashLoan = await FlashLoan.deploy();
    
    // Fork mainnet
    await network.provider.request({
        method: "hardhat_reset",
        params: [{
            forking: {
                jsonRpcUrl: MAINNET_RPC,
                blockNumber: 15000000
            }
        }]
    });
    
    // Execute flash loan
    await flashLoan.executeFlashLoan(USDC, ethers.utils.parseUnits("1000000", 6));
    
    // Check profit
    const profit = await usdc.balanceOf(flashLoan.address);
    expect(profit).to.be.gt(0);
});
```

## Conclusion

Flash loans are a powerful DeFi primitive enabling capital-efficient strategies impossible in traditional finance. They require deep technical knowledge, careful risk management, and thorough testing. While they enable legitimate use cases like arbitrage and collateral swaps, they've also been used in numerous attacks, making security paramount.

---

*Next: DeFi Security and Auditing*
