# Automated Market Makers (AMMs)

## Overview

Automated Market Makers (AMMs) are smart contracts that create liquidity pools of token pairs and enable automated trading without traditional order books. They are the foundation of decentralized exchanges (DEXs) in DeFi.

## Traditional Order Books vs AMMs

### Order Book Model
- Buyers and sellers place limit orders
- Requires market makers to provide liquidity
- Matching engine pairs buy/sell orders
- Can have low liquidity for certain pairs

### AMM Model
- Liquidity pools replace order books
- Anyone can become a liquidity provider (LP)
- Algorithmic pricing based on pool ratios
- Always available liquidity (with slippage)

## Core AMM Concepts

### Liquidity Pools
A liquidity pool is a smart contract containing reserves of two or more tokens. Users trade against these pools rather than with other traders directly.

**Example Pool:**
```
ETH/USDC Pool
- 100 ETH
- 200,000 USDC
- Price: 1 ETH = 2,000 USDC
```

### Liquidity Providers (LPs)
Users who deposit tokens into pools to earn trading fees. LPs receive LP tokens representing their share of the pool.

**LP Token Calculation:**
```
LP_tokens = (deposited_value / total_pool_value) × total_LP_tokens
```

### Slippage
The difference between expected and executed price due to trade size relative to pool liquidity.

```
Slippage = (executed_price - expected_price) / expected_price × 100%
```

## AMM Pricing Formulas

### 1. Constant Product Market Maker (CPMM)

**Formula:** `x × y = k`

Where:
- `x` = reserve of token A
- `y` = reserve of token B  
- `k` = constant product

**Used by:** Uniswap V2, SushiSwap, PancakeSwap

**Example Trade:**
```
Initial State:
- ETH reserve: 100
- USDC reserve: 200,000
- k = 100 × 200,000 = 20,000,000

User swaps 10 ETH for USDC:
- New ETH reserve: 110
- New USDC reserve: 20,000,000 / 110 = 181,818.18
- USDC received: 200,000 - 181,818.18 = 18,181.82 USDC
- Effective price: 1,818.18 USDC per ETH (vs 2,000 spot)
```

**Price Impact:**
```
price_impact = 1 - (output_amount / (input_amount × spot_price))
```

### 2. Constant Sum Market Maker (CSMM)

**Formula:** `x + y = k`

- Zero slippage
- Infinite liquidity at a single price
- Vulnerable to arbitrage
- Not practical for most use cases

**Used by:** Rarely in production (theoretical model)

### 3. Constant Mean Market Maker (CMMM)

**Formula:** `(x₁^w₁) × (x₂^w₂) × ... × (xₙ^wₙ) = k`

Where:
- `xᵢ` = reserve of token i
- `wᵢ` = weight of token i
- Sum of all weights = 1

**Used by:** Balancer

**Example:**
```
Pool with 80% ETH, 20% USDC:
(ETH^0.8) × (USDC^0.2) = k
```

### 4. StableSwap (Hybrid CPMM + CSMM)

**Formula:** `An^n Σxᵢ + D = ADn^n + D^(n+1)/(n^n Πxᵢ)`

Where:
- `A` = amplification coefficient
- `D` = invariant
- `n` = number of tokens
- `xᵢ` = token balances

**Used by:** Curve Finance

**Characteristics:**
- Low slippage for similar-priced assets
- Behaves like CSMM near equilibrium
- Behaves like CPMM at extremes
- Ideal for stablecoin swaps

### 5. Concentrated Liquidity

**Used by:** Uniswap V3

Instead of providing liquidity across the entire price curve (0 to ∞), LPs can concentrate liquidity within specific price ranges.

**Benefits:**
- Capital efficiency (up to 4000x)
- Higher fee earnings per unit of capital
- Customizable risk/reward profiles

**Formula:**
```
L = Δy / (√P_b - √P_a)
```

Where:
- `L` = liquidity
- `Δy` = amount of token Y
- `P_a` = lower price bound
- `P_b` = upper price bound

## Impermanent Loss

### Definition
The opportunity cost of providing liquidity compared to simply holding the tokens.

### Mathematical Formula

For a 50/50 pool with price change ratio `r`:

```
IL = 2√r / (1 + r) - 1
```

**Examples:**
- 1.25x price change: -0.6% IL
- 1.5x price change: -2.0% IL
- 2x price change: -5.7% IL
- 5x price change: -25.5% IL
- 10x price change: -42.0% IL

### Mitigation Strategies
1. **Provide liquidity to correlated pairs** (ETH/stETH)
2. **Use stablecoin pairs** (USDC/DAI)
3. **Earn sufficient fees** to offset IL
4. **Use single-sided liquidity** (Bancor V3)
5. **Concentrated liquidity** in narrow ranges

## Fee Structures

### Uniswap V2
- 0.3% fee per swap
- 100% goes to LPs

### Uniswap V3
- Multiple fee tiers: 0.01%, 0.05%, 0.3%, 1%
- LPs choose tier based on volatility

### Curve
- Variable fees (typically 0.04%)
- 50% to LPs, 50% to veCRV holders

### Balancer
- Customizable fees (0.0001% to 10%)
- Set by pool creators

## Advanced AMM Concepts

### Just-In-Time (JIT) Liquidity
LPs add liquidity right before a large trade and remove it immediately after to capture fees without IL risk.

### MEV and Sandwich Attacks
Attackers front-run user trades by:
1. Buying tokens before user's trade
2. User's trade executes at worse price
3. Attacker sells at profit

### Dynamic Fees
Fees that adjust based on:
- Volatility
- Pool utilization
- Market conditions

### Virtual Reserves
Some AMMs use virtual reserves to improve pricing:
```
(x + x_virtual) × (y + y_virtual) = k
```

## AMM Innovations

### 1. Uniswap V4 Hooks
Customizable logic that executes at specific points in the swap lifecycle.

### 2. Maverick Protocol
Directional liquidity that automatically follows price movements.

### 3. Trader Joe's Liquidity Book
Discretized liquidity bins for improved capital efficiency.

### 4. Ambient Finance
Combines concentrated and ambient liquidity in a single pool.

## AMM Security Considerations

### 1. Reentrancy Attacks
Malicious contracts calling back into AMM during execution.

**Mitigation:** Checks-Effects-Interactions pattern, reentrancy guards

### 2. Flash Loan Attacks
Manipulating pool prices with borrowed capital.

**Mitigation:** Time-weighted average prices (TWAP), oracle redundancy

### 3. Front-Running
Bots observing mempool and placing trades before users.

**Mitigation:** Private transactions, MEV protection services

### 4. Liquidity Draining
Exploiting vulnerabilities to extract pool funds.

**Mitigation:** Audits, formal verification, bug bounties

## Code Example: Simple CPMM

```solidity
contract SimpleAMM {
    uint256 public reserveA;
    uint256 public reserveB;
    uint256 public constant FEE = 3; // 0.3%
    
    function swap(
        uint256 amountIn,
        bool isTokenA
    ) external returns (uint256 amountOut) {
        uint256 amountInWithFee = amountIn * (1000 - FEE);
        
        if (isTokenA) {
            amountOut = (amountInWithFee * reserveB) / 
                       (reserveA * 1000 + amountInWithFee);
            reserveA += amountIn;
            reserveB -= amountOut;
        } else {
            amountOut = (amountInWithFee * reserveA) / 
                       (reserveB * 1000 + amountInWithFee);
            reserveB += amountIn;
            reserveA -= amountOut;
        }
    }
    
    function addLiquidity(
        uint256 amountA,
        uint256 amountB
    ) external returns (uint256 liquidity) {
        // Simplified LP token calculation
        liquidity = sqrt(amountA * amountB);
        reserveA += amountA;
        reserveB += amountB;
    }
}
```

## Conclusion

AMMs revolutionized DeFi by enabling permissionless, automated trading. Understanding their mathematical foundations, trade-offs, and risks is essential for anyone building or using DeFi protocols.

---

*Next: Lending and Borrowing Protocols*
