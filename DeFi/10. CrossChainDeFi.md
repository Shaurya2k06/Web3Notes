# Cross-Chain DeFi

## Overview

Cross-chain DeFi enables assets and data to move between different blockchain networks, expanding liquidity and composability across ecosystems.

## Bridge Types

### 1. Lock and Mint Bridges

**Mechanism:**
```
Source Chain:
1. Lock native asset in smart contract
2. Emit event

Destination Chain:
3. Mint wrapped version of asset
4. User receives wrapped tokens
```

**Example: WBTC (Wrapped Bitcoin)**
```
Bitcoin → Ethereum
1. Send BTC to custodian
2. Custodian locks BTC
3. Mint WBTC on Ethereum (1:1 ratio)
4. User receives WBTC

Redemption:
1. Burn WBTC
2. Custodian releases BTC
```

**Pros:**
- Simple mechanism
- Maintains 1:1 peg

**Cons:**
- Centralized custody
- Trust required
- Single point of failure


### 2. Burn and Mint Bridges

**Mechanism:**
```
Source Chain:
1. Burn tokens
2. Emit event

Destination Chain:
3. Mint equivalent tokens
4. User receives tokens
```

**Example: Multichain (formerly Anyswap)**
```
Ethereum → Polygon
1. Burn USDC on Ethereum
2. Mint anyUSDC on Polygon

Return:
1. Burn anyUSDC on Polygon
2. Mint USDC on Ethereum
```

**Pros:**
- No custodian needed
- True cross-chain tokens
- Scalable

**Cons:**
- Requires trust in bridge validators
- Liquidity fragmentation
- Complexity

### 3. Liquidity Network Bridges

**Mechanism:**
```
Source Chain:
1. Lock tokens in pool
2. Emit event

Destination Chain:
3. Release tokens from pool
4. User receives tokens

Liquidity providers earn fees
```

**Example: Hop Protocol**
```
Ethereum → Arbitrum (fast)
1. User locks ETH on Ethereum
2. Bonder fronts ETH on Arbitrum instantly
3. User receives ETH on Arbitrum
4. Bonder reimbursed when L1→L2 message confirms

Fee: 0.04% + gas
Speed: Minutes instead of hours
```

**Pros:**
- Fast transfers
- Good UX
- Decentralized liquidity

**Cons:**
- Requires liquidity on both sides
- Bonder capital requirements
- Slippage on large transfers

### 4. Atomic Swaps

**Mechanism:** Hash Time-Locked Contracts (HTLCs)

**Process:**
```
1. Alice generates secret S, hashes to H
2. Alice locks BTC with HTLC: "Release to Bob if he provides S within 24h"
3. Bob locks ETH with HTLC: "Release to Alice if she provides S within 12h"
4. Alice claims ETH by revealing S
5. Bob uses S to claim BTC

If either party doesn't participate:
- Funds return after timeout
- No trust required
```

**Code Example:**
```solidity
contract HTLC {
    struct Swap {
        address payable sender;
        address payable receiver;
        uint256 amount;
        bytes32 hashlock;
        uint256 timelock;
        bool withdrawn;
        bool refunded;
    }
    
    mapping(bytes32 => Swap) public swaps;
    
    function newSwap(
        address payable receiver,
        bytes32 hashlock,
        uint256 timelock
    ) external payable returns (bytes32) {
        require(msg.value > 0, "Amount must be > 0");
        require(timelock > block.timestamp, "Timelock in past");
        
        bytes32 swapId = keccak256(abi.encodePacked(
            msg.sender,
            receiver,
            msg.value,
            hashlock,
            timelock
        ));
        
        swaps[swapId] = Swap({
            sender: payable(msg.sender),
            receiver: receiver,
            amount: msg.value,
            hashlock: hashlock,
            timelock: timelock,
            withdrawn: false,
            refunded: false
        });
        
        return swapId;
    }
    
    function withdraw(bytes32 swapId, bytes32 preimage) external {
        Swap storage swap = swaps[swapId];
        require(!swap.withdrawn, "Already withdrawn");
        require(!swap.refunded, "Already refunded");
        require(swap.hashlock == keccak256(abi.encodePacked(preimage)), "Invalid preimage");
        
        swap.withdrawn = true;
        swap.receiver.transfer(swap.amount);
    }
    
    function refund(bytes32 swapId) external {
        Swap storage swap = swaps[swapId];
        require(!swap.withdrawn, "Already withdrawn");
        require(!swap.refunded, "Already refunded");
        require(block.timestamp >= swap.timelock, "Timelock not expired");
        
        swap.refunded = true;
        swap.sender.transfer(swap.amount);
    }
}
```

**Pros:**
- Trustless
- No intermediaries
- Atomic (all or nothing)

**Cons:**
- Complex UX
- Both parties must be online
- Limited to simple swaps
- Not widely used

## Cross-Chain Messaging Protocols

### 1. LayerZero

**Architecture:**

**Components:**
```
1. Endpoint: Smart contract on each chain
2. Oracle: Provides block headers
3. Relayer: Submits transaction proofs
4. User Application: Your dApp
```

**Message Flow:**
```
Source Chain:
1. User calls send() on Endpoint
2. Endpoint emits event
3. Oracle reads block header
4. Relayer reads transaction proof

Destination Chain:
5. Oracle submits block header
6. Relayer submits proof
7. Endpoint validates and delivers message
8. User Application receives message
```

**Security Model:**
```
Oracle + Relayer must both be honest
If either is malicious, message fails
User can choose their own Oracle/Relayer
```

**Code Example:**
```solidity
import "@layerzerolabs/contracts/lzApp/NonblockingLzApp.sol";

contract CrossChainToken is NonblockingLzApp {
    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}
    
    function sendTokens(
        uint16 _dstChainId,
        address _to,
        uint256 _amount
    ) external payable {
        require(balanceOf(msg.sender) >= _amount, "Insufficient balance");
        
        // Burn tokens on source chain
        _burn(msg.sender, _amount);
        
        // Encode message
        bytes memory payload = abi.encode(_to, _amount);
        
        // Send cross-chain message
        _lzSend(
            _dstChainId,
            payload,
            payable(msg.sender),
            address(0),
            bytes(""),
            msg.value
        );
    }
    
    function _nonblockingLzReceive(
        uint16 _srcChainId,
        bytes memory _srcAddress,
        uint64 _nonce,
        bytes memory _payload
    ) internal override {
        // Decode message
        (address to, uint256 amount) = abi.decode(_payload, (address, uint256));
        
        // Mint tokens on destination chain
        _mint(to, amount);
    }
}
```

**Protocols Using LayerZero:**
- Stargate (stablecoin bridge)
- Radiant Capital (omnichain lending)
- Trader Joe (cross-chain DEX)

### 2. Axelar

**Architecture:**

**Components:**
```
1. Gateway: Smart contract on each chain
2. Validators: Decentralized validator set
3. Relayers: Submit transactions
```

**Security:**
```
- Proof-of-Stake validator network
- 2/3+ validators must sign messages
- Slashing for misbehavior
- Permissionless relaying
```

**General Message Passing (GMP):**
```solidity
import "@axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol";

contract CrossChainApp is AxelarExecutable {
    constructor(address gateway_) AxelarExecutable(gateway_) {}
    
    function sendMessage(
        string calldata destinationChain,
        string calldata destinationAddress,
        string calldata message
    ) external payable {
        bytes memory payload = abi.encode(message);
        gateway.callContract(destinationChain, destinationAddress, payload);
    }
    
    function _execute(
        string calldata sourceChain,
        string calldata sourceAddress,
        bytes calldata payload
    ) internal override {
        string memory message = abi.decode(payload, (string));
        // Handle message
    }
}
```

### 3. Wormhole

**Architecture:**

**Components:**
```
1. Core Contract: On each chain
2. Guardians: 19 validators
3. Relayers: Submit VAAs (Verified Action Approvals)
```

**Message Flow:**
```
1. Emit message on source chain
2. Guardians observe and sign
3. 13/19 signatures required
4. Relayer submits VAA to destination
5. Core contract verifies signatures
6. Message delivered
```

**Token Bridge:**
```
1. Lock tokens on source chain
2. Guardians attest
3. Mint wrapped tokens on destination
```

**Famous Hack (Feb 2022):**
```
Loss: $325 million
Vulnerability: Signature verification bypass
Method: Forged guardian signatures
Impact: Minted 120,000 ETH on Solana
Resolution: Jump Crypto covered losses
```

### 4. Chainlink CCIP

**Cross-Chain Interoperability Protocol:**

**Features:**
```
- Decentralized oracle network
- Risk management network
- Programmable token transfers
- Arbitrary messaging
```

**Security Layers:**
```
1. Decentralized Oracle Network (DON)
2. Risk Management Network (independent validation)
3. Rate limiting
4. Anomaly detection
```

**Code Example:**
```solidity
import "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol";

contract CCIPSender {
    IRouterClient public router;
    
    function sendMessage(
        uint64 destinationChainSelector,
        address receiver,
        string memory message
    ) external {
        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({
            receiver: abi.encode(receiver),
            data: abi.encode(message),
            tokenAmounts: new Client.EVMTokenAmount[](0),
            extraArgs: Client._argsToBytes(
                Client.EVMExtraArgsV1({gasLimit: 200_000, strict: false})
            ),
            feeToken: address(0)
        });
        
        uint256 fees = router.getFee(destinationChainSelector, evm2AnyMessage);
        
        router.ccipSend{value: fees}(destinationChainSelector, evm2AnyMessage);
    }
}
```

## Cross-Chain DeFi Protocols

### 1. Stargate Finance

**Omnichain liquidity protocol:**

**Features:**
```
- Instant guaranteed finality
- Native assets (not wrapped)
- Unified liquidity pools
- Delta algorithm for balance
```

**Delta Algorithm:**
```
Prevents liquidity imbalance across chains

If Chain A has excess liquidity:
- Cheaper to bridge from A
- More expensive to bridge to A

If Chain B needs liquidity:
- More expensive to bridge from B
- Cheaper to bridge to B

Self-balancing mechanism
```

**Example:**
```
Bridge USDC: Ethereum → Arbitrum

1. Lock USDC on Ethereum
2. Stargate message via LayerZero
3. Release USDC on Arbitrum
4. User receives native USDC (not wrapped)

Fee: 0.06% + gas
Time: ~5 minutes
```

### 2. Synapse Protocol

**Cross-chain bridge and AMM:**

**Features:**
```
- Bridge any asset
- Cross-chain swaps
- Liquidity pools on each chain
- SYN token incentives
```

**Mechanism:**
```
1. Swap on source chain
2. Bridge canonical asset
3. Swap on destination chain

Example: ETH (Ethereum) → AVAX (Avalanche)
1. Swap ETH → USDC on Ethereum
2. Bridge USDC to Avalanche
3. Swap USDC → AVAX on Avalanche

All in one transaction!
```

### 3. Across Protocol

**Optimistic bridge:**

**Mechanism:**
```
1. User requests transfer
2. Relayer fronts funds instantly
3. Relayer reimbursed after challenge period
4. If fraud detected, relayer slashed

Speed: Seconds
Security: Optimistic (7-day challenge)
```

**Fee Structure:**
```
Base Fee: 0.04%
LP Fee: Variable (based on utilization)
Relayer Fee: Variable (based on speed)

Total: ~0.1-0.5%
```

### 4. Celer cBridge

**Liquidity network bridge:**

**Features:**
```
- Fast transfers (minutes)
- Low fees (0.04%)
- 40+ chains supported
- State Guardian Network (SGN)
```

**SGN (State Guardian Network):**
```
- PoS validator network
- Monitors bridge state
- Resolves disputes
- Slashing for misbehavior
```

## Cross-Chain Risks

### 1. Bridge Hacks

**Major Incidents:**

**Ronin Bridge (March 2022):**
```
Loss: $625 million
Method: Compromised validator keys (5/9)
Cause: Social engineering
Impact: Largest DeFi hack ever
```

**Poly Network (Aug 2021):**
```
Loss: $611 million (returned)
Method: Exploited cross-chain message verification
Cause: Access control vulnerability
```

**Wormhole (Feb 2022):**
```
Loss: $325 million
Method: Signature verification bypass
Cause: Smart contract bug
```

**BNB Bridge (Oct 2022):**
```
Loss: $586 million
Method: Forged proof
Cause: Merkle proof verification bug
```

**Total Bridge Losses (2021-2023):**
```
> $2.5 billion stolen
Bridges are #1 DeFi attack vector
```

### 2. Centralization Risks

**Multi-Sig Bridges:**
```
Pros:
- Simple
- Fast
- Cheap

Cons:
- Centralized
- Key management risk
- Single point of failure
```

**Validator Sets:**
```
Small validator sets (< 20):
- Easier to compromise
- Collusion risk
- Regulatory pressure

Large validator sets (> 100):
- More decentralized
- Harder to compromise
- Slower consensus
```

### 3. Liquidity Risks

**Fragmentation:**
```
Same asset on multiple chains:
- ETH on Ethereum
- WETH on Polygon
- anyETH on Fantom
- hETH on Harmony

Problems:
- Liquidity split
- Price discrepancies
- Complexity for users
```

**Imbalanced Pools:**
```
If everyone bridges one direction:
- Source chain depleted
- Destination chain excess
- Bridge becomes one-way
- High fees to rebalance
```

### 4. Message Verification Risks

**Oracle Failures:**
```
- Oracle provides wrong data
- Messages delivered incorrectly
- Funds lost or stuck
```

**Relayer Failures:**
```
- Relayer goes offline
- Messages not delivered
- Funds stuck in limbo
```

**Consensus Failures:**
```
- Chain reorganizations
- Finality issues
- Double-spend attacks
```

## Cross-Chain Security Best Practices

### 1. For Users

**Due Diligence:**
```
- Check bridge audit reports
- Verify bridge TVL and age
- Start with small amounts
- Use established bridges
- Understand risks
```

**Transaction Safety:**
```
- Double-check destination address
- Verify chain IDs
- Set slippage limits
- Save transaction hashes
- Monitor completion
```

### 2. For Developers

**Security Measures:**
```
- Multi-layered validation
- Rate limiting
- Anomaly detection
- Circuit breakers
- Upgrade mechanisms
```

**Code Example: Rate Limiting**
```solidity
contract RateLimitedBridge {
    uint256 public constant RATE_LIMIT = 1000 ether;
    uint256 public constant TIME_WINDOW = 1 hours;
    
    mapping(uint256 => uint256) public hourlyVolume;
    
    function bridge(uint256 amount) external {
        uint256 currentHour = block.timestamp / 1 hours;
        
        require(
            hourlyVolume[currentHour] + amount <= RATE_LIMIT,
            "Rate limit exceeded"
        );
        
        hourlyVolume[currentHour] += amount;
        
        // Bridge logic
    }
}
```

**Circuit Breaker:**
```solidity
contract CircuitBreakerBridge {
    bool public paused;
    address public guardian;
    uint256 public pausedAt;
    
    modifier whenNotPaused() {
        require(!paused, "Bridge paused");
        _;
    }
    
    function pause() external {
        require(msg.sender == guardian, "Not guardian");
        paused = true;
        pausedAt = block.timestamp;
        emit Paused();
    }
    
    function unpause() external {
        require(msg.sender == guardian, "Not guardian");
        require(block.timestamp > pausedAt + 24 hours, "Too soon");
        paused = false;
        emit Unpaused();
    }
}
```

## Future of Cross-Chain DeFi

### Trends

**1. Native Cross-Chain Protocols:**
```
- Built cross-chain from day one
- No "main" chain
- Unified liquidity
- Seamless UX
```

**2. Intent-Based Bridging:**
```
- User specifies desired outcome
- Solvers compete to fulfill
- Best execution guaranteed
- No need to understand bridges
```

**3. Zero-Knowledge Bridges:**
```
- ZK proofs for message verification
- Trustless and fast
- No validator sets needed
- Mathematically secure
```

**4. Interoperability Standards:**
```
- Common messaging format
- Shared security layer
- Composable bridges
- Reduced fragmentation
```

### Innovations

**Cosmos IBC (Inter-Blockchain Communication):**
```
- Native cross-chain protocol
- Light client verification
- Trustless
- Fast finality
```

**Polkadot XCM (Cross-Consensus Messaging):**
```
- Shared security via relay chain
- Parachains communicate natively
- No bridges needed
- Unified ecosystem
```

**Ethereum L2 Interoperability:**
```
- Shared L1 security
- Fast L2-to-L2 transfers
- Unified liquidity
- Native messaging
```

## Conclusion

Cross-chain DeFi is essential for a multi-chain future but remains one of the riskiest areas. Bridges are complex systems with large attack surfaces. As the technology matures, we'll see more secure, efficient, and user-friendly cross-chain solutions. Until then, users should exercise caution and developers should prioritize security above all else.

---

*Next: Real World Assets (RWA)*
