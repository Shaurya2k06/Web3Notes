# DeFi Composability

## Overview

Composability is DeFi's superpower - the ability to combine protocols like "money legos" to create new financial products. It's what makes DeFi more than the sum of its parts.

## What is Composability?

### Definition

The ability for different protocols to seamlessly interact and build upon each other without permission.

**Key Properties:**
1. **Permissionless:** No approval needed to integrate
2. **Atomic:** Operations succeed or fail together
3. **Synchronous:** Instant execution within one transaction
4. **Transparent:** All code is open and auditable

### The Money Lego Analogy

```
Traditional Finance:
- Walled gardens
- APIs require partnerships
- Slow integration (months/years)
- Permission required

DeFi:
- Open protocols
- Direct smart contract calls
- Instant integration (hours/days)
- Permissionless
```

## Composability Examples

### 1. Leveraged Yield Farming

Combine lending + DEX + yield farming:

```
1. Deposit ETH to Aave
2. Borrow USDC against ETH
3. Swap USDC to ETH on Uniswap
4. Deposit ETH to Aave
5. Repeat (recursive leverage)
6. Stake LP tokens for rewards

All in one transaction!
```


**Code Example:**
```solidity
contract LeveragedYieldFarming {
    IAave public aave;
    IUniswap public uniswap;
    IYearn public yearn;
    
    function executeStrategy(uint256 ethAmount) external payable {
        require(msg.value == ethAmount, "Incorrect ETH");
        
        // 1. Deposit ETH to Aave
        aave.deposit{value: ethAmount}(ETH, ethAmount, address(this), 0);
        
        // 2. Borrow USDC (75% LTV)
        uint256 usdcToBorrow = (ethAmount * 1500) * 75 / 100; // Assuming ETH = $2000
        aave.borrow(USDC, usdcToBorrow, 2, 0, address(this));
        
        // 3. Swap USDC to ETH on Uniswap
        uint256 ethReceived = uniswap.swapExactTokensForETH(
            usdcToBorrow,
            0,
            getPath(USDC, ETH),
            address(this),
            block.timestamp
        );
        
        // 4. Deposit ETH to Aave again
        aave.deposit{value: ethReceived}(ETH, ethReceived, address(this), 0);
        
        // 5. Repeat 2-3 more times for higher leverage
        
        // 6. Stake aTokens in Yearn for boosted yield
        uint256 aTokenBalance = aave.balanceOf(address(this));
        yearn.deposit(aTokenBalance);
    }
}
```

### 2. Flash Loan Arbitrage

Combine flash loans + DEX swaps:

```solidity
contract FlashArbitrage {
    function executeArbitrage() external {
        // 1. Flash loan 1000 ETH from Aave
        uint256 amount = 1000 ether;
        aave.flashLoan(address(this), ETH, amount, data);
    }
    
    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address initiator,
        bytes calldata params
    ) external returns (bool) {
        // 2. Sell ETH on Uniswap
        uint256 usdcReceived = uniswap.swapExactTokensForTokens(
            amount,
            0,
            pathETHtoUSDC,
            address(this),
            deadline
        );
        
        // 3. Buy ETH on Sushiswap (cheaper)
        uint256 ethReceived = sushiswap.swapExactTokensForTokens(
            usdcReceived,
            0,
            pathUSDCtoETH,
            address(this),
            deadline
        );
        
        // 4. Repay flash loan + fee
        uint256 amountOwed = amount + premium;
        IERC20(asset).approve(address(aave), amountOwed);
        
        // 5. Keep profit
        uint256 profit = ethReceived - amountOwed;
        
        return true;
    }
}
```

### 3. Collateral Swapping

Change collateral without closing position:

```
1. Flash loan repayment token
2. Repay debt on Protocol A
3. Withdraw collateral from Protocol A
4. Swap collateral to new asset
5. Deposit new collateral to Protocol B
6. Borrow to repay flash loan

Result: Moved position between protocols atomically
```

### 4. Yield Aggregation

Automatically move funds to highest yield:

```
1. Check yields across protocols
2. Withdraw from lower-yield protocol
3. Swap tokens if needed
4. Deposit to higher-yield protocol
5. Compound rewards

All in one transaction!
```

## Composability Patterns

### 1. Token Wrapping

**Concept:** Wrap tokens to make them compatible with other protocols.

**Examples:**
```
ETH → WETH (ERC-20 compatible)
BTC → WBTC (Ethereum-compatible)
stETH → wstETH (non-rebasing version)
aUSDC → waUSDC (wrapped Aave token)
```

**Use Case:**
```
Problem: Uniswap requires ERC-20 tokens
Solution: Wrap ETH to WETH

1. Deposit ETH to WETH contract
2. Receive WETH 1:1
3. Use WETH in Uniswap
4. Unwrap back to ETH anytime
```

**Code:**
```solidity
contract WETH {
    mapping(address => uint256) public balanceOf;
    
    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
    }
    
    function withdraw(uint256 amount) public {
        require(balanceOf[msg.sender] >= amount);
        balanceOf[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }
}
```

### 2. Yield Tokenization

**Concept:** Separate principal from yield.

**Pendle Example:**
```
Deposit: 100 aUSDC (earning 5% APY)

Receive:
- 100 PT-aUSDC (Principal Token)
- 100 YT-aUSDC (Yield Token)

PT-aUSDC:
- Redeemable for 100 USDC at maturity
- Trade at discount (present value)

YT-aUSDC:
- Receives all yield until maturity
- Speculate on yield rates
```

**Strategies:**
```
Fixed Yield:
- Buy PT at discount
- Hold to maturity
- Guaranteed return

Yield Speculation:
- Buy YT if expecting high yields
- Sell YT if expecting low yields

Hedging:
- Hold PT, sell YT
- Lock in fixed rate
```

### 3. Liquidity Provision as Collateral

**Concept:** Use LP tokens as collateral for borrowing.

**Example:**
```
1. Provide liquidity to Uniswap ETH/USDC
2. Receive UNI-V2 LP tokens
3. Deposit LP tokens to Aave
4. Borrow against LP tokens
5. Earn trading fees + borrow more capital

Triple yield:
- Trading fees from Uniswap
- Farming rewards
- Borrowed capital deployed elsewhere
```

**Risk:**
```
- Impermanent loss
- Liquidation risk
- Smart contract risk across multiple protocols
```

### 4. Recursive Strategies

**Concept:** Repeatedly use the same protocol for amplification.

**Leveraged Staking:**
```
1. Stake 100 ETH on Lido → 100 stETH
2. Deposit 100 stETH to Aave
3. Borrow 80 ETH (80% LTV)
4. Stake 80 ETH on Lido → 80 stETH
5. Deposit 80 stETH to Aave
6. Borrow 64 ETH
7. Repeat...

Final Position:
- 500 ETH staked (5x leverage)
- 400 ETH debt
- 5x staking rewards
- Liquidation risk if stETH depegs
```

**Formula:**
```
Max Leverage = 1 / (1 - LTV)

80% LTV: 1 / 0.2 = 5x
75% LTV: 1 / 0.25 = 4x
50% LTV: 1 / 0.5 = 2x
```

### 5. Cross-Protocol Arbitrage

**Concept:** Exploit price differences across protocols.

**Example:**
```
1. ETH on Uniswap: $2,000
2. ETH on Sushiswap: $2,010

Arbitrage:
1. Buy 100 ETH on Uniswap ($200,000)
2. Sell 100 ETH on Sushiswap ($201,000)
3. Profit: $1,000 (minus gas)

All in one transaction (atomic)
```

## Composability Risks

### 1. Cascading Failures

**Scenario:**
```
Protocol A depends on Protocol B
Protocol B depends on Protocol C
Protocol C gets hacked

Result:
- Protocol C fails
- Protocol B loses funds
- Protocol A becomes insolvent
- Users of all three protocols affected
```

**Historical Example: Iron Finance (June 2021)**
```
IRON stablecoin depeg:
1. IRON partially backed by TITAN token
2. TITAN price crashes
3. IRON depegs
4. Bank run on IRON
5. TITAN goes to $0
6. IRON goes to $0

Composability amplified the collapse
```

### 2. Oracle Manipulation

**Scenario:**
```
Multiple protocols use same oracle
Oracle gets manipulated
All dependent protocols affected simultaneously
```

**Example:**
```
1. Attacker manipulates Uniswap price oracle
2. Protocol A reads manipulated price
3. Protocol B uses Protocol A's price
4. Protocol C uses Protocol B's price
5. All three protocols exploited
```

### 3. Liquidity Crunch

**Scenario:**
```
Protocol A borrows from Protocol B
Protocol B borrows from Protocol C
Sudden withdrawal demand
Cascading liquidity crisis
```

**Example:**
```
1. Users withdraw from Protocol C
2. Protocol C recalls loans from Protocol B
3. Protocol B forced to recall loans from Protocol A
4. Protocol A forced to liquidate positions
5. Market crash amplifies losses
```

### 4. Gas Price Spikes

**Scenario:**
```
Complex composable transaction requires high gas
Gas prices spike during execution
Transaction fails or becomes unprofitable
```

**Mitigation:**
```
- Gas price limits
- Flashbots for MEV protection
- Layer 2 solutions
- Batch transactions
```

### 5. Smart Contract Risk Multiplication

**Risk Calculation:**
```
Single protocol: 1% risk
Two protocols: 1 - (0.99 × 0.99) = 1.99% risk
Three protocols: 1 - (0.99^3) = 2.97% risk
Five protocols: 1 - (0.99^5) = 4.90% risk

Risk compounds with each additional protocol
```

## Composability Enablers

### 1. Standard Interfaces

**ERC-20:**
```solidity
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}
```

**Benefits:**
```
- Universal token standard
- Any protocol can integrate
- Predictable behavior
- Composable by default
```

**ERC-4626 (Tokenized Vaults):**
```solidity
interface IERC4626 {
    function asset() external view returns (address);
    function totalAssets() external view returns (uint256);
    function convertToShares(uint256 assets) external view returns (uint256);
    function convertToAssets(uint256 shares) external view returns (uint256);
    function deposit(uint256 assets, address receiver) external returns (uint256 shares);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);
}
```

**Benefits:**
```
- Standard vault interface
- Easy integration
- Composable yield strategies
- Interoperable vaults
```

### 2. Modular Architecture

**Concept:** Build protocols as composable modules.

**Example: Uniswap V4 Hooks**
```solidity
interface IHooks {
    function beforeSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params)
        external returns (bytes4);
    
    function afterSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, BalanceDelta delta)
        external returns (bytes4);
    
    function beforeAddLiquidity(address sender, PoolKey calldata key, IPoolManager.ModifyPositionParams calldata params)
        external returns (bytes4);
    
    function afterAddLiquidity(address sender, PoolKey calldata key, IPoolManager.ModifyPositionParams calldata params, BalanceDelta delta)
        external returns (bytes4);
}
```

**Use Cases:**
```
- Custom fee logic
- Dynamic pricing
- MEV protection
- Limit orders
- TWAP oracles
- Volatility oracles
```

### 3. Proxy Patterns

**Upgradeable Contracts:**
```solidity
contract Proxy {
    address public implementation;
    
    fallback() external payable {
        address impl = implementation;
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
}
```

**Benefits:**
```
- Upgrade logic without changing address
- Fix bugs post-deployment
- Add features over time
- Maintain composability
```

**Risks:**
```
- Centralization (who controls upgrades?)
- Storage collisions
- Initialization issues
- Complexity
```

### 4. Adapter Patterns

**Concept:** Wrappers that make protocols compatible.

**Example:**
```solidity
contract AaveToCompoundAdapter {
    IAave public aave;
    ICompound public compound;
    
    function deposit(address token, uint256 amount) external {
        // Accept Compound-style deposit
        // Convert to Aave deposit
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        IERC20(token).approve(address(aave), amount);
        aave.deposit(token, amount, msg.sender, 0);
    }
    
    function withdraw(address token, uint256 amount) external {
        // Accept Compound-style withdrawal
        // Convert to Aave withdrawal
        aave.withdraw(token, amount, msg.sender);
    }
}
```

## Advanced Composability

### 1. Intent-Based Architecture

**Concept:** Users specify desired outcome, solvers compete to fulfill.

**Example:**
```
User Intent:
"I want 1000 USDC on Arbitrum, I have ETH on Ethereum"

Solver Options:
1. Bridge ETH → Swap to USDC on Arbitrum
2. Swap to USDC on Ethereum → Bridge USDC
3. Use cross-chain DEX aggregator
4. Flash loan on Arbitrum, repay from Ethereum

Best solver wins and executes
```

**Benefits:**
```
- Simplified UX
- Optimal execution
- Competitive pricing
- Abstracted complexity
```

**Protocols:**
- UniswapX
- CoW Protocol
- 1inch Fusion

### 2. Account Abstraction (ERC-4337)

**Concept:** Smart contract wallets with programmable logic.

**Composability Benefits:**
```
- Batch transactions
- Automated strategies
- Gasless transactions
- Social recovery
- Custom validation logic
```

**Example:**
```solidity
contract SmartWallet {
    function executeBatch(Call[] calldata calls) external {
        for (uint i = 0; i < calls.length; i++) {
            (bool success, ) = calls[i].target.call(calls[i].data);
            require(success, "Call failed");
        }
    }
    
    function autoCompound() external {
        // 1. Claim rewards from all protocols
        yearn.claimRewards();
        curve.claimRewards();
        convex.claimRewards();
        
        // 2. Swap all rewards to base asset
        swapAllToETH();
        
        // 3. Reinvest
        depositToYearn(address(this).balance);
    }
}
```

### 3. Cross-Chain Composability

**Concept:** Compose protocols across different chains.

**Example:**
```
1. Borrow USDC on Ethereum (Aave)
2. Bridge to Arbitrum (Stargate)
3. Swap to ETH (Uniswap)
4. Provide liquidity (Camelot)
5. Stake LP tokens (Yield farm)

All triggered from single transaction on Ethereum
```

**Challenges:**
```
- Asynchronous execution
- Cross-chain message passing
- Failure handling
- Gas costs
```

### 4. Modular Blockchains

**Concept:** Separate execution, settlement, consensus, data availability.

**Composability Benefits:**
```
- Shared liquidity layer
- Unified state
- Cross-rollup communication
- Atomic cross-chain transactions
```

**Example: Cosmos IBC**
```
- Chains communicate natively
- Atomic cross-chain swaps
- Shared security (optional)
- Composable ecosystem
```

## Composability Best Practices

### 1. For Developers

**Design Principles:**
```
- Use standard interfaces
- Make contracts modular
- Avoid unnecessary state
- Emit comprehensive events
- Document thoroughly
- Consider composability from day one
```

**Security:**
```
- Reentrancy guards
- Checks-Effects-Interactions
- Access control
- Rate limiting
- Circuit breakers
```

**Testing:**
```
- Test integrations with other protocols
- Fork mainnet for testing
- Simulate complex scenarios
- Stress test edge cases
```

### 2. For Users

**Risk Management:**
```
- Understand all protocols involved
- Check audit reports
- Start with small amounts
- Monitor positions regularly
- Have exit strategies
```

**Due Diligence:**
```
- Verify contract addresses
- Check protocol TVL and age
- Review recent exploits
- Understand liquidation risks
- Calculate worst-case scenarios
```

## Future of Composability

### Trends

**1. Increased Abstraction:**
```
- Users don't need to know underlying protocols
- Intent-based interfaces
- AI-powered optimization
- One-click strategies
```

**2. Cross-Chain Native:**
```
- Seamless multi-chain composability
- Unified liquidity
- Chain-agnostic protocols
- Instant cross-chain execution
```

**3. Modular Everything:**
```
- Plug-and-play components
- Customizable DeFi stacks
- Specialized modules
- Interoperable standards
```

**4. Automated Strategies:**
```
- AI-driven portfolio management
- Automated rebalancing
- Risk-adjusted optimization
- Self-healing positions
```

### Innovations

**Hooks and Plugins:**
```
- Uniswap V4 hooks
- Aave V3 flash loan receivers
- Compound III custom logic
- Extensible protocols
```

**Shared Sequencers:**
```
- Atomic cross-rollup transactions
- Unified MEV auction
- Synchronized state
- True composability across L2s
```

**Intents and Solvers:**
```
- User specifies outcome
- Market of solvers competes
- Optimal execution guaranteed
- Abstracted complexity
```

## Conclusion

Composability is DeFi's killer feature, enabling innovation at unprecedented speed. By combining protocols like legos, developers create sophisticated financial products impossible in traditional finance. However, composability also amplifies risks, requiring careful design, thorough testing, and constant vigilance. As DeFi matures, composability will become even more powerful with better standards, cross-chain integration, and abstraction layers that make complexity invisible to users.

---

*Next: Liquid Staking*
