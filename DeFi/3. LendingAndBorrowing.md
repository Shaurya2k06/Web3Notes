# Lending and Borrowing Protocols

## Overview

DeFi lending protocols allow users to lend crypto assets to earn interest or borrow assets by providing collateral. These protocols operate autonomously through smart contracts without traditional intermediaries.

## Core Concepts

### Lenders (Suppliers)
Users who deposit assets into lending pools to earn interest. Interest rates are determined algorithmically based on supply and demand.

### Borrowers
Users who take loans by providing collateral. Loans are typically overcollateralized to protect lenders from default risk.

### Collateral
Assets deposited to secure a loan. If collateral value drops below a threshold, the position can be liquidated.

### Liquidation
The process of selling a borrower's collateral when their position becomes undercollateralized.

## Interest Rate Models

### Utilization Rate

The key metric driving interest rates:

```
Utilization Rate (U) = Total Borrowed / Total Supplied
```

**Example:**
```
Pool has 1000 ETH supplied
500 ETH borrowed
U = 500 / 1000 = 50%
```

### Linear Interest Rate Model

**Borrow Rate:**
```
if U < U_optimal:
    Borrow_Rate = Base_Rate + (U / U_optimal) × Rate_Slope_1
else:
    Borrow_Rate = Base_Rate + Rate_Slope_1 + 
                  ((U - U_optimal) / (1 - U_optimal)) × Rate_Slope_2
```

**Supply Rate:**
```
Supply_Rate = Borrow_Rate × U × (1 - Reserve_Factor)
```

Where:
- `U_optimal` = target utilization (typically 80-90%)
- `Base_Rate` = minimum borrow rate
- `Rate_Slope_1` = rate increase below optimal
- `Rate_Slope_2` = steep rate increase above optimal
- `Reserve_Factor` = protocol fee (typically 10-20%)

### Compound's Interest Rate Model

**Example Parameters:**
```
Base Rate: 2% APY
Multiplier (Slope 1): 10% per utilization
Jump Multiplier (Slope 2): 100% per utilization
Kink (U_optimal): 80%
```

**At 50% Utilization:**
```
Borrow Rate = 2% + (50% / 80%) × 10% = 8.25% APY
Supply Rate = 8.25% × 50% × 90% = 3.71% APY
```

**At 90% Utilization:**
```
Borrow Rate = 2% + 10% + ((90% - 80%) / 20%) × 100% = 62% APY
Supply Rate = 62% × 90% × 90% = 50.22% APY
```

### Aave's Interest Rate Strategy

Aave uses a similar kinked model with additional parameters:

```solidity
if U < U_optimal:
    variableBorrowRate = baseVariableBorrowRate + 
                        (U / U_optimal) × variableRateSlope1
else:
    variableBorrowRate = baseVariableBorrowRate + variableRateSlope1 +
                        ((U - U_optimal) / (1 - U_optimal)) × variableRateSlope2

stableBorrowRate = baseStableBorrowRate + stableRateSlope1 + stableRateSlope2
```

## Collateralization

### Loan-to-Value (LTV) Ratio

Maximum amount that can be borrowed against collateral:

```
Max Borrow = Collateral Value × LTV
```

**Example:**
```
Deposit: 10 ETH @ $2,000 = $20,000
LTV: 75%
Max Borrow: $20,000 × 0.75 = $15,000
```

### Liquidation Threshold

The collateralization ratio at which liquidation occurs:

```
Health Factor = (Collateral Value × Liquidation Threshold) / Borrowed Value
```

**Liquidation triggers when Health Factor < 1**

**Example:**
```
Collateral: $20,000 ETH
Liquidation Threshold: 80%
Borrowed: $15,000 USDC

Health Factor = ($20,000 × 0.80) / $15,000 = 1.067

If ETH drops to $1,875:
Collateral Value = $18,750
Health Factor = ($18,750 × 0.80) / $15,000 = 1.0 (liquidation imminent)

If ETH drops to $1,850:
Health Factor = ($18,500 × 0.80) / $15,000 = 0.987 (liquidation triggered)
```

### Liquidation Penalty

Bonus paid to liquidators for closing undercollateralized positions:

```
Liquidation Bonus = 5-15% (varies by asset and protocol)
```

**Liquidation Example:**
```
Borrowed: $15,000 USDC
Collateral: $18,500 ETH (undercollateralized)
Liquidation Penalty: 10%

Liquidator repays: $15,000 USDC
Liquidator receives: $15,000 × 1.10 = $16,500 worth of ETH
Profit: $1,500
```

## Compound Protocol

### cTokens

When you supply assets to Compound, you receive cTokens (e.g., cDAI, cETH) representing your share of the pool plus accrued interest.

**Exchange Rate:**
```
exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
```

**Redeeming:**
```
underlyingAmount = cTokenAmount × exchangeRate
```

**Example:**
```
Initial: 1 cDAI = 0.020000 DAI
After 1 year: 1 cDAI = 0.020800 DAI (4% APY)

Deposit 1000 DAI → Receive 50,000 cDAI
After 1 year: 50,000 cDAI = 1,040 DAI
```

### Compound Interest Accrual

Interest compounds every Ethereum block (~12 seconds):

```
newIndex = oldIndex × (1 + borrowRate × blockDelta / blocksPerYear)
```

**Continuous Compounding:**
```
APY = (1 + APR / blocksPerYear)^blocksPerYear - 1
```

### COMP Token Distribution

Compound distributes COMP tokens to users proportional to interest accrued:

```
COMP_earned = (user_interest / total_interest) × COMP_per_block × blocks
```

## Aave Protocol

### aTokens

Similar to cTokens but with 1:1 peg to underlying asset. Interest accrues directly to aToken balance.

**Balance Growth:**
```
aToken_balance = principal × liquidityIndex / depositIndex
```

### Stable vs Variable Rates

**Variable Rate:**
- Fluctuates with utilization
- Typically lower than stable rate
- Can spike during high demand

**Stable Rate:**
- Fixed at time of borrowing
- Can be rebalanced by protocol if too far from market
- Provides predictability

### Flash Loans

Uncollateralized loans that must be borrowed and repaid within a single transaction.

**Requirements:**
```
borrowed_amount + fee ≤ repaid_amount (in same transaction)
```

**Fee:** Typically 0.09% of borrowed amount

**Use Cases:**
1. Arbitrage across DEXs
2. Collateral swaps
3. Self-liquidation
4. Debt refinancing

**Example Flash Loan:**
```solidity
function executeFlashLoan(uint256 amount) external {
    // 1. Borrow 1000 ETH from Aave
    // 2. Swap on DEX A: 1000 ETH → 2,000,000 USDC
    // 3. Swap on DEX B: 2,000,000 USDC → 1005 ETH
    // 4. Repay 1000.9 ETH (1000 + 0.09% fee)
    // 5. Keep profit: 4.1 ETH
}
```

### Isolation Mode

Aave V3 feature allowing new assets to be listed with limited risk:

- Isolated assets can only be used as collateral alone
- Borrowing is limited to specific stablecoins
- Debt ceiling caps total borrowing

### E-Mode (Efficiency Mode)

Higher LTV for correlated assets:

**Standard Mode:**
```
ETH collateral → 75% LTV for any asset
```

**E-Mode (ETH category):**
```
ETH collateral → 90% LTV for other ETH derivatives (stETH, rETH)
```

## MakerDAO

### Collateralized Debt Positions (CDPs) / Vaults

Users lock collateral in vaults to mint DAI stablecoin.

**Key Parameters:**

1. **Collateralization Ratio:**
```
Collateralization Ratio = (Collateral Value / DAI Debt) × 100%
```

2. **Minimum Collateralization Ratio:**
```
ETH-A: 145%
ETH-B: 130%
WBTC-A: 145%
```

3. **Stability Fee:**
Annual interest rate on DAI debt (e.g., 0.5% - 5%)

4. **Liquidation Penalty:**
Fee charged during liquidation (e.g., 13%)

**Example Vault:**
```
Deposit: 10 ETH @ $2,000 = $20,000
Mint: 10,000 DAI
Collateralization Ratio: 200%

If ETH drops to $1,500:
Collateral Value: $15,000
Ratio: 150%

If ETH drops to $1,450:
Collateral Value: $14,500
Ratio: 145% (liquidation triggered)

Liquidation:
- Debt: 10,000 DAI
- Penalty: 13%
- Total owed: 11,300 DAI
- Collateral sold: $11,300 worth of ETH
- Remaining collateral returned to user
```

### DAI Savings Rate (DSR)

Risk-free interest rate for holding DAI:

```
DAI_earned = DAI_deposited × (1 + DSR)^time - DAI_deposited
```

### Liquidation Mechanism

MakerDAO uses auction-based liquidation:

1. **Collateral Auction:** Sell collateral for DAI
2. **Debt Auction:** Mint MKR to cover bad debt
3. **Surplus Auction:** Sell excess DAI for MKR (burned)

## Risk Parameters

### Asset Risk Factors

Protocols adjust parameters based on:

1. **Liquidity:** On-chain trading volume
2. **Volatility:** Price stability
3. **Market Cap:** Total value and distribution
4. **Smart Contract Risk:** Audit status, complexity
5. **Centralization:** Control and governance

**Example Risk Tiers:**

**Tier 1 (Blue Chip):**
```
Assets: ETH, WBTC, USDC
LTV: 80-85%
Liquidation Threshold: 85-90%
Liquidation Penalty: 5%
```

**Tier 2 (Established):**
```
Assets: LINK, AAVE, UNI
LTV: 70-75%
Liquidation Threshold: 80-85%
Liquidation Penalty: 10%
```

**Tier 3 (Emerging):**
```
Assets: Newer tokens
LTV: 40-60%
Liquidation Threshold: 65-75%
Liquidation Penalty: 15%
```

## Advanced Concepts

### Recursive Borrowing (Leverage)

Maximize exposure by repeatedly supplying and borrowing:

```
Initial: 100 ETH
1. Supply 100 ETH
2. Borrow 75 ETH (75% LTV)
3. Supply 75 ETH
4. Borrow 56.25 ETH
5. Supply 56.25 ETH
...

Total Exposure = Initial / (1 - LTV) = 100 / 0.25 = 400 ETH
Leverage = 4x
```

**Risk:** Higher liquidation risk due to increased debt.

### Credit Delegation

Aave feature allowing users to delegate borrowing power:

```
User A deposits 100 ETH
User A delegates 50 ETH borrowing power to User B
User B can borrow up to 50 ETH worth without collateral
User A's collateral backs User B's loan
```

### Isolated Lending Pools

Separate pools for risky assets to prevent contagion:

- Rari Capital (Fuse)
- Silo Finance
- Euler Finance

Each pool has independent risk parameters.

## Security Considerations

### Oracle Manipulation

Protocols rely on price oracles (Chainlink, Band Protocol):

**Attack Vector:**
```
1. Manipulate oracle price feed
2. Borrow maximum against inflated collateral
3. Collateral price corrects
4. Protocol left with bad debt
```

**Mitigation:**
- Multiple oracle sources
- Time-weighted average prices (TWAP)
- Circuit breakers for large price movements

### Flash Loan Attacks

**Example Attack:**
```
1. Flash loan 100M USDC
2. Manipulate price oracle by draining AMM pool
3. Borrow maximum against manipulated price
4. Repay flash loan
5. Keep borrowed funds
```

**Mitigation:**
- Decentralized oracles
- Manipulation-resistant price feeds
- Borrowing caps

### Smart Contract Risks

- Reentrancy attacks
- Integer overflow/underflow
- Access control vulnerabilities
- Upgrade risks

## Code Example: Simple Lending Pool

```solidity
contract SimpleLendingPool {
    mapping(address => uint256) public deposits;
    mapping(address => uint256) public borrows;
    uint256 public totalDeposits;
    uint256 public totalBorrows;
    
    uint256 public constant LTV = 75; // 75%
    uint256 public constant LIQUIDATION_THRESHOLD = 80; // 80%
    uint256 public constant BASE_RATE = 2; // 2%
    
    function deposit() external payable {
        deposits[msg.sender] += msg.value;
        totalDeposits += msg.value;
    }
    
    function borrow(uint256 amount) external {
        uint256 maxBorrow = (deposits[msg.sender] * LTV) / 100;
        require(borrows[msg.sender] + amount <= maxBorrow, "Exceeds LTV");
        
        borrows[msg.sender] += amount;
        totalBorrows += amount;
        payable(msg.sender).transfer(amount);
    }
    
    function getHealthFactor(address user) public view returns (uint256) {
        if (borrows[user] == 0) return type(uint256).max;
        return (deposits[user] * LIQUIDATION_THRESHOLD) / (borrows[user] * 100);
    }
    
    function liquidate(address user) external {
        require(getHealthFactor(user) < 100, "Position healthy");
        
        uint256 debtToCover = borrows[user];
        uint256 collateralToLiquidate = (debtToCover * 110) / 100; // 10% bonus
        
        // Transfer collateral to liquidator
        deposits[user] -= collateralToLiquidate;
        borrows[user] = 0;
    }
    
    function getUtilization() public view returns (uint256) {
        if (totalDeposits == 0) return 0;
        return (totalBorrows * 100) / totalDeposits;
    }
    
    function getBorrowRate() public view returns (uint256) {
        uint256 utilization = getUtilization();
        return BASE_RATE + (utilization * 10) / 100; // Simplified
    }
}
```

## Conclusion

Lending and borrowing protocols are fundamental DeFi primitives enabling capital efficiency and leverage. Understanding interest rate models, collateralization, and liquidation mechanics is crucial for safe participation.

---

*Next: Stablecoins*
