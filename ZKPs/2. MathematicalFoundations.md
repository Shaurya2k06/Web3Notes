# Mathematical Foundations of Zero-Knowledge Proofs

## Overview

Zero-Knowledge Proofs are built on deep mathematical foundations from number theory, abstract algebra, and cryptography. This document covers the essential mathematical concepts needed to understand and implement ZKPs.

## Number Theory Basics

### Modular Arithmetic

**Definition:**
```
a ≡ b (mod n) means n divides (a - b)

Example:
17 ≡ 5 (mod 12)
Because 17 - 5 = 12, and 12 divides 12
```

**Properties:**
```
Addition: (a + b) mod n = ((a mod n) + (b mod n)) mod n
Multiplication: (a × b) mod n = ((a mod n) × (b mod n)) mod n
Exponentiation: a^b mod n (computed efficiently)

Example:
(15 + 8) mod 7 = 23 mod 7 = 2
(15 mod 7 + 8 mod 7) mod 7 = (1 + 1) mod 7 = 2
```

**Modular Inverse:**
```
a^(-1) mod n is the number x such that:
a × x ≡ 1 (mod n)

Example:
3^(-1) mod 7 = 5
Because 3 × 5 = 15 ≡ 1 (mod 7)

Exists only if gcd(a, n) = 1
```

**Extended Euclidean Algorithm:**
```python
def extended_gcd(a, b):
    if a == 0:
        return b, 0, 1
    gcd, x1, y1 = extended_gcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return gcd, x, y

def mod_inverse(a, m):
    gcd, x, y = extended_gcd(a, m)
    if gcd != 1:
        return None  # Inverse doesn't exist
    return (x % m + m) % m

# Example
print(mod_inverse(3, 7))  # Output: 5
```

### Prime Numbers

**Definition:**
```
A prime number p is a natural number greater than 1
that has no positive divisors other than 1 and itself.

Examples: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31...
```

**Fermat's Little Theorem:**
```
If p is prime and a is not divisible by p:
a^(p-1) ≡ 1 (mod p)

Example:
p = 7, a = 3
3^6 mod 7 = 729 mod 7 = 1 ✓

Useful for:
- Primality testing
- Computing modular inverses: a^(-1) ≡ a^(p-2) (mod p)
```

**Euler's Totient Function:**
```
φ(n) = count of numbers ≤ n that are coprime to n

For prime p: φ(p) = p - 1
For p, q prime: φ(pq) = (p-1)(q-1)

Example:
φ(7) = 6 (numbers 1,2,3,4,5,6 are coprime to 7)
φ(15) = φ(3×5) = (3-1)(5-1) = 8
```

**Euler's Theorem:**
```
If gcd(a, n) = 1:
a^φ(n) ≡ 1 (mod n)

Generalizes Fermat's Little Theorem
```

### Discrete Logarithm Problem

**Definition:**
```
Given: g, h, and modulus p
Find: x such that g^x ≡ h (mod p)

This is the foundation of many cryptographic systems
```

**Example:**
```
g = 5, p = 23
x = 7 (secret)
h = 5^7 mod 23 = 78125 mod 23 = 17

Easy direction (exponentiation):
Given g=5, x=7, p=23 → compute h=17 (fast)

Hard direction (discrete log):
Given g=5, h=17, p=23 → find x=7 (slow for large p)
```

**Computational Complexity:**
```
Exponentiation: O(log n) using fast exponentiation
Discrete Log: O(√p) using baby-step giant-step
            or O(e^(log p)^(1/3)) using index calculus

For 256-bit primes: Effectively impossible
```

**Fast Exponentiation:**
```python
def fast_exp(base, exp, mod):
    result = 1
    base = base % mod
    while exp > 0:
        if exp % 2 == 1:
            result = (result * base) % mod
        exp = exp >> 1
        base = (base * base) % mod
    return result

# Example: 5^7 mod 23
print(fast_exp(5, 7, 23))  # Output: 17

# Binary representation of 7: 111
# 5^7 = 5^4 × 5^2 × 5^1
# Only 3 multiplications instead of 6
```

## Group Theory

### Groups

**Definition:**
```
A group (G, ×) is a set G with operation × satisfying:

1. Closure: For all a, b ∈ G, a × b ∈ G
2. Associativity: (a × b) × c = a × (b × c)
3. Identity: There exists e ∈ G such that a × e = e × a = a
4. Inverse: For each a ∈ G, there exists a^(-1) such that a × a^(-1) = e
```

**Examples:**
```
Integers under addition: (ℤ, +)
- Closure: ✓
- Identity: 0
- Inverse: -a for each a

Integers mod n under addition: (ℤ_n, +)
- Example: ℤ_7 = {0, 1, 2, 3, 4, 5, 6}
- Identity: 0
- Inverse of 3: 4 (because 3 + 4 = 7 ≡ 0 mod 7)

Non-zero integers mod p under multiplication: (ℤ_p*, ×)
- For prime p
- Example: ℤ_7* = {1, 2, 3, 4, 5, 6}
- Identity: 1
- Inverse of 3: 5 (because 3 × 5 = 15 ≡ 1 mod 7)
```

### Cyclic Groups

**Definition:**
```
A group G is cyclic if there exists g ∈ G such that
every element of G can be written as g^k for some integer k.

g is called a generator of G.
```

**Example:**
```
ℤ_7* = {1, 2, 3, 4, 5, 6} under multiplication mod 7

Generator g = 3:
3^1 mod 7 = 3
3^2 mod 7 = 2
3^3 mod 7 = 6
3^4 mod 7 = 4
3^5 mod 7 = 5
3^6 mod 7 = 1

All elements generated! So 3 is a generator.

Generator g = 5:
5^1 mod 7 = 5
5^2 mod 7 = 4
5^3 mod 7 = 6
5^4 mod 7 = 2
5^5 mod 7 = 3
5^6 mod 7 = 1

5 is also a generator!
```

**Finding Generators:**
```python
def is_generator(g, p):
    """Check if g is a generator of ℤ_p*"""
    seen = set()
    current = 1
    for i in range(p - 1):
        current = (current * g) % p
        if current in seen:
            return False
        seen.add(current)
    return len(seen) == p - 1

# Find all generators of ℤ_7*
p = 7
generators = [g for g in range(1, p) if is_generator(g, p)]
print(generators)  # Output: [3, 5]
```

### Subgroups

**Definition:**
```
H is a subgroup of G if:
1. H ⊆ G
2. H is itself a group under the same operation
```

**Lagrange's Theorem:**
```
If H is a subgroup of finite group G:
|H| divides |G|

Example:
G = ℤ_7* = {1, 2, 3, 4, 5, 6}, |G| = 6
Possible subgroup sizes: 1, 2, 3, 6

H = {1, 6} is a subgroup of size 2:
6 × 6 = 36 ≡ 1 (mod 7)
Identity: 1
Inverse of 6: 6
```

## Elliptic Curves

### Elliptic Curve Definition

**Weierstrass Form:**
```
y² = x³ + ax + b (mod p)

Where:
- a, b are constants
- p is a prime
- 4a³ + 27b² ≠ 0 (non-singular)
```

**Example: secp256k1 (Bitcoin/Ethereum):**
```
y² = x³ + 7 (mod p)

Where:
p = 2^256 - 2^32 - 977 (large prime)
a = 0
b = 7
```

**Points on the Curve:**
```
A point P = (x, y) satisfies the curve equation
Plus a special "point at infinity" O (identity element)

Example: y² = x³ + 7 (mod 17)
Point (5, 8):
8² = 64 ≡ 13 (mod 17)
5³ + 7 = 132 ≡ 13 (mod 17)
✓ Valid point
```

### Elliptic Curve Group Law

**Point Addition:**
```
Given points P = (x₁, y₁) and Q = (x₂, y₂)
Compute R = P + Q = (x₃, y₃)

If P ≠ Q (point addition):
λ = (y₂ - y₁) / (x₂ - x₁) mod p
x₃ = λ² - x₁ - x₂ mod p
y₃ = λ(x₁ - x₃) - y₁ mod p

If P = Q (point doubling):
λ = (3x₁² + a) / (2y₁) mod p
x₃ = λ² - 2x₁ mod p
y₃ = λ(x₁ - x₃) - y₁ mod p

Identity: P + O = P
Inverse: P + (-P) = O, where -P = (x, -y)
```

**Example:**
```python
class EllipticCurve:
    def __init__(self, a, b, p):
        self.a = a
        self.b = b
        self.p = p
    
    def add(self, P, Q):
        if P is None:  # O + Q = Q
            return Q
        if Q is None:  # P + O = P
            return P
        
        x1, y1 = P
        x2, y2 = Q
        
        if x1 == x2:
            if y1 == y2:  # Point doubling
                lam = (3 * x1 * x1 + self.a) * mod_inverse(2 * y1, self.p)
            else:  # P + (-P) = O
                return None
        else:  # Point addition
            lam = (y2 - y1) * mod_inverse(x2 - x1, self.p)
        
        lam = lam % self.p
        x3 = (lam * lam - x1 - x2) % self.p
        y3 = (lam * (x1 - x3) - y1) % self.p
        
        return (x3, y3)
    
    def multiply(self, k, P):
        """Scalar multiplication: k * P"""
        if k == 0 or P is None:
            return None
        if k == 1:
            return P
        if k < 0:
            return self.multiply(-k, (P[0], -P[1] % self.p))
        
        result = None
        addend = P
        
        while k:
            if k & 1:
                result = self.add(result, addend)
            addend = self.add(addend, addend)
            k >>= 1
        
        return result

# Example: y² = x³ + 7 (mod 17)
curve = EllipticCurve(0, 7, 17)
P = (5, 8)
Q = (10, 11)

R = curve.add(P, Q)
print(f"P + Q = {R}")

# Scalar multiplication
k = 5
kP = curve.multiply(k, P)
print(f"5P = {kP}")
```

### Elliptic Curve Discrete Logarithm Problem (ECDLP)

**Problem:**
```
Given: Points G and Q on elliptic curve
Find: k such that Q = k × G

Easy direction: Given k, compute Q = k × G (fast)
Hard direction: Given Q, find k (slow)
```

**Security:**
```
For 256-bit curves:
- Best known attack: O(√n) ≈ 2^128 operations
- Quantum attack (Shor's): O((log n)³) operations
- Currently secure against classical computers
- Vulnerable to large quantum computers
```

### Pairing-Based Cryptography

**Bilinear Pairing:**
```
A pairing e: G₁ × G₂ → G_T satisfies:

1. Bilinearity: e(aP, bQ) = e(P, Q)^(ab)
2. Non-degeneracy: e(G, G) ≠ 1
3. Computability: e can be efficiently computed

Where G₁, G₂ are elliptic curve groups, G_T is target group
```

**Properties:**
```
e(P + R, Q) = e(P, Q) · e(R, Q)
e(P, Q + S) = e(P, Q) · e(P, S)
e(aP, bQ) = e(P, Q)^(ab) = e(bP, aQ)
```

**Applications:**
```
- Identity-based encryption
- Short signatures (BLS)
- zk-SNARKs (Groth16, PLONK)
- Attribute-based encryption
```

**Example: BLS Signature Verification:**
```
Public key: pk = sk × G₂
Signature: σ = sk × H(m)  (H maps message to G₁)

Verification:
e(σ, G₂) = e(H(m), pk)
e(sk × H(m), G₂) = e(H(m), sk × G₂)
e(H(m), G₂)^sk = e(H(m), G₂)^sk ✓
```

## Polynomial Arithmetic

### Polynomials over Finite Fields

**Definition:**
```
P(x) = a_n·x^n + a_(n-1)·x^(n-1) + ... + a_1·x + a_0

Where coefficients a_i are in a finite field F_p
```

**Example:**
```
F_7 = {0, 1, 2, 3, 4, 5, 6}
P(x) = 3x² + 5x + 2 (mod 7)

P(1) = 3·1² + 5·1 + 2 = 10 ≡ 3 (mod 7)
P(2) = 3·4 + 5·2 + 2 = 24 ≡ 3 (mod 7)
P(4) = 3·16 + 5·4 + 2 = 70 ≡ 0 (mod 7)
```

**Operations:**
```
Addition: (P + Q)(x) = P(x) + Q(x) mod p
Multiplication: (P · Q)(x) = P(x) · Q(x) mod p
Evaluation: P(a) for a ∈ F_p

Example:
P(x) = 2x + 3 (mod 7)
Q(x) = 4x + 1 (mod 7)

(P + Q)(x) = 6x + 4 (mod 7)
(P · Q)(x) = 8x² + 14x + 3 ≡ x² + 3 (mod 7)
```

### Lagrange Interpolation

**Theorem:**
```
Given n points (x₁, y₁), ..., (xₙ, yₙ) with distinct x_i,
there exists a unique polynomial P(x) of degree < n such that:
P(x_i) = y_i for all i
```

**Formula:**
```
P(x) = Σ y_i · L_i(x)

Where L_i(x) = Π_(j≠i) (x - x_j) / (x_i - x_j)

L_i(x_i) = 1
L_i(x_j) = 0 for j ≠ i
```

**Example:**
```
Points: (1, 3), (2, 5), (3, 4) in F_7

L₁(x) = ((x-2)(x-3)) / ((1-2)(1-3)) = (x²-5x+6) / 2 mod 7
L₂(x) = ((x-1)(x-3)) / ((2-1)(2-3)) = (x²-4x+3) / (-1) mod 7
L₃(x) = ((x-1)(x-2)) / ((3-1)(3-2)) = (x²-3x+2) / 2 mod 7

P(x) = 3·L₁(x) + 5·L₂(x) + 4·L₃(x) mod 7
```

**Python Implementation:**
```python
def lagrange_interpolation(points, p):
    """
    Interpolate polynomial through points in F_p
    points: list of (x, y) tuples
    p: prime modulus
    """
    n = len(points)
    
    def L_i(i, x):
        """Lagrange basis polynomial"""
        xi, yi = points[i]
        result = 1
        for j in range(n):
            if i != j:
                xj, _ = points[j]
                result *= (x - xj) * mod_inverse(xi - xj, p)
                result %= p
        return result
    
    def P(x):
        """Interpolated polynomial"""
        result = 0
        for i in range(n):
            _, yi = points[i]
            result += yi * L_i(i, x)
            result %= p
        return result
    
    return P

# Example
points = [(1, 3), (2, 5), (3, 4)]
p = 7
P = lagrange_interpolation(points, p)

print(f"P(1) = {P(1)}")  # Should be 3
print(f"P(2) = {P(2)}")  # Should be 5
print(f"P(3) = {P(3)}")  # Should be 4
print(f"P(4) = {P(4)}")  # Extrapolation
```

### Polynomial Commitment Schemes

**Kate-Zaverucha-Goldberg (KZG) Commitments:**

**Setup:**
```
Choose random secret s
Compute powers: [G, sG, s²G, ..., s^nG]
Publish as public parameters (s is destroyed)
```

**Commit:**
```
Polynomial: P(x) = a₀ + a₁x + a₂x² + ... + a_nx^n
Commitment: C = a₀G + a₁(sG) + a₂(s²G) + ... + a_n(s^nG)
           = P(s)·G
```

**Prove Evaluation:**
```
Claim: P(z) = y
Quotient: Q(x) = (P(x) - y) / (x - z)
Proof: π = Q(s)·G

Verification using pairing:
e(C - yG, G) = e(π, sG - zG)
e(P(s)G - yG, G) = e(Q(s)G, (s-z)G)
e((P(s) - y)G, G) = e(Q(s)G, (s-z)G)
```

**Properties:**
```
- Constant size commitment (1 group element)
- Constant size proof (1 group element)
- Constant verification time
- Requires trusted setup
- Binding and hiding (with blinding factor)
```

## Hash Functions

### Cryptographic Hash Functions

**Properties:**
```
1. Deterministic: Same input → same output
2. Fast computation
3. Pre-image resistance: Hard to find x given H(x)
4. Second pre-image resistance: Hard to find x' ≠ x with H(x') = H(x)
5. Collision resistance: Hard to find x, x' with H(x) = H(x')
```

**Common Hash Functions:**
```
SHA-256: 256-bit output, widely used
SHA-3 (Keccak): 256-bit output, newer standard
BLAKE2: Fast, secure
Poseidon: ZK-friendly (few constraints)
```

### Hash Functions in ZKPs

**Challenge:**
```
Standard hashes (SHA-256) are expensive in ZK circuits
Each bit operation requires constraints
SHA-256: ~25,000 constraints
```

**ZK-Friendly Hashes:**

**Poseidon:**
```
- Designed for ZK circuits
- Based on algebraic operations
- ~150 constraints per hash
- 100x more efficient than SHA-256
```

**MiMC:**
```
- Minimal Multiplicative Complexity
- Very few constraints
- Based on x^3 operations
- Fast in ZK circuits
```

**Rescue:**
```
- Designed for STARKs
- Algebraic hash function
- Efficient in ZK proofs
```

**Example: Poseidon Hash:**
```
State: [x₁, x₂, ..., x_t]

Round function:
1. Add round constants
2. Apply S-box: x → x^α
3. Mix with MDS matrix

Repeat for R rounds

Output: First element of final state
```

## Commitment Schemes

### Pedersen Commitment

**Setup:**
```
Choose generators g, h of group G
(discrete log of h w.r.t. g is unknown)
```

**Commit:**
```
Commit(m, r) = g^m · h^r

Where:
- m = message
- r = random blinding factor
```

**Properties:**
```
Hiding: Given C, cannot determine m (information-theoretically)
Binding: Cannot find m, r and m', r' with same commitment (computationally)
Homomorphic: Commit(m₁, r₁) · Commit(m₂, r₂) = Commit(m₁+m₂, r₁+r₂)
```

**Example:**
```python
class PedersenCommitment:
    def __init__(self, g, h, p):
        self.g = g
        self.h = h
        self.p = p
    
    def commit(self, message, randomness):
        """Commit to message with randomness"""
        return (pow(self.g, message, self.p) * 
                pow(self.h, randomness, self.p)) % self.p
    
    def verify(self, commitment, message, randomness):
        """Verify opening of commitment"""
        return commitment == self.commit(message, randomness)

# Example
p = 23  # Prime
g = 5   # Generator
h = 7   # Another generator

pc = PedersenCommitment(g, h, p)

message = 10
randomness = 15

commitment = pc.commit(message, randomness)
print(f"Commitment: {commitment}")

# Verify
is_valid = pc.verify(commitment, message, randomness)
print(f"Valid: {is_valid}")
```

### Merkle Trees

**Structure:**
```
        Root
       /    \
      H₁₂   H₃₄
     /  \   /  \
    H₁  H₂ H₃  H₄
    |   |  |   |
    L₁  L₂ L₃  L₄  (Leaves)
```

**Construction:**
```
1. Hash each leaf: H_i = Hash(L_i)
2. Hash pairs: H₁₂ = Hash(H₁ || H₂)
3. Continue until root
```

**Merkle Proof:**
```
Prove L₂ is in tree:
Provide: [L₂, H₁, H₃₄]

Verification:
1. Compute H₂ = Hash(L₂)
2. Compute H₁₂ = Hash(H₁ || H₂)
3. Compute Root = Hash(H₁₂ || H₃₄)
4. Check Root matches known root
```

**Properties:**
```
- Proof size: O(log n)
- Verification: O(log n)
- Commitment to set of values
- Efficient membership proofs
```

## Conclusion

The mathematical foundations of zero-knowledge proofs span multiple areas of mathematics including number theory, abstract algebra, and cryptography. Understanding these foundations is essential for implementing and analyzing ZKP systems. The discrete logarithm problem, elliptic curves, polynomial arithmetic, and commitment schemes form the building blocks upon which modern ZKP systems like zk-SNARKs and zk-STARKs are constructed.

---

*Next: Interactive Zero-Knowledge Proofs*
