# Interactive Zero-Knowledge Proofs

## Overview

Interactive zero-knowledge proofs involve multiple rounds of communication between a prover and verifier. The verifier sends random challenges, and the prover responds with answers that convince the verifier without revealing the secret.

## Sigma Protocols

### Definition

A Sigma (Σ) protocol is a three-move interactive proof with the structure:

```
Prover                    Verifier
  |                          |
  |----Commitment (a)------->|
  |                          |
  |<---Challenge (c)---------|
  |                          |
  |----Response (z)--------->|
  |                          |
                        Verify
```

**Properties:**
```
1. Three moves: Commitment → Challenge → Response
2. Special soundness: Can extract witness from two accepting transcripts
3. Special honest-verifier zero-knowledge (HVZK)
```

## Schnorr Protocol

### The Protocol

**Goal:** Prove knowledge of discrete logarithm x such that h = g^x

**Public Parameters:**
```
- Group G of prime order q
- Generator g
- Public key h = g^x (x is secret)
```

**Protocol Steps:**

**1. Commitment:**
```
Prover:
- Choose random r ∈ Z_q
- Compute a = g^r
- Send a to Verifier
```

**2. Challenge:**
```
Verifier:
- Choose random c ∈ Z_q
- Send c to Prover
```

**3. Response:**
```
Prover:
- Compute z = r + c·x mod q
- Send z to Verifier
```

**4. Verification:**
```
Verifier:
- Check if g^z = a · h^c
- Accept if true, reject otherwise
```

### Correctness Proof

```
g^z = g^(r + cx)
    = g^r · g^(cx)
    = a · (g^x)^c
    = a · h^c ✓
```

### Security Analysis

**Completeness:**
```
If Prover knows x and follows protocol:
g^z = g^(r+cx) = g^r · (g^x)^c = a · h^c
Verifier always accepts ✓
```

**Soundness:**
```
If Prover doesn't know x:
- Must guess challenge c before seeing it
- Probability of guessing: 1/q (negligible)
- Can extract x from two valid transcripts:

Transcript 1: (a, c₁, z₁) where g^z₁ = a · h^c₁
Transcript 2: (a, c₂, z₂) where g^z₂ = a · h^c₂

From these:
g^z₁ / g^z₂ = h^c₁ / h^c₂
g^(z₁-z₂) = h^(c₁-c₂)
g^(z₁-z₂) = (g^x)^(c₁-c₂)
g^(z₁-z₂) = g^(x(c₁-c₂))

Therefore: x = (z₁ - z₂) / (c₁ - c₂) mod q
```

**Zero-Knowledge:**
```
Simulator (without knowing x):
1. Choose random c, z
2. Compute a = g^z · h^(-c)
3. Output transcript (a, c, z)

This transcript is indistinguishable from real protocol
because c is random in both cases.
```

### Implementation

```python
import random
from hashlib import sha256

class SchnorrProtocol:
    def __init__(self, g, h, q, x=None):
        self.g = g  # Generator
        self.h = h  # Public key h = g^x
        self.q = q  # Group order
        self.x = x  # Secret (prover only)
    
    def commit(self):
        """Prover: Generate commitment"""
        self.r = random.randint(1, self.q - 1)
        a = pow(self.g, self.r, self.q)
        return a
    
    def challenge(self):
        """Verifier: Generate random challenge"""
        c = random.randint(1, self.q - 1)
        return c
    
    def respond(self, c):
        """Prover: Compute response"""
        z = (self.r + c * self.x) % (self.q - 1)
        return z
    
    def verify(self, a, c, z):
        """Verifier: Verify proof"""
        left = pow(self.g, z, self.q)
        right = (a * pow(self.h, c, self.q)) % self.q
        return left == right

# Example usage
q = 23  # Prime
g = 5   # Generator
x = 7   # Secret
h = pow(g, x, q)  # Public key: 5^7 mod 23 = 17

# Prover
prover = SchnorrProtocol(g, h, q, x)
a = prover.commit()
print(f"Commitment: {a}")

# Verifier
verifier = SchnorrProtocol(g, h, q)
c = verifier.challenge()
print(f"Challenge: {c}")

# Prover
z = prover.respond(c)
print(f"Response: {z}")

# Verifier
is_valid = verifier.verify(a, c, z)
print(f"Proof valid: {is_valid}")
```

## Chaum-Pedersen Protocol

### The Protocol

**Goal:** Prove knowledge of x such that h₁ = g₁^x AND h₂ = g₂^x

**Public Parameters:**
```
- Generators g₁, g₂
- Public values h₁ = g₁^x, h₂ = g₂^x
- Secret x
```

**Protocol:**

**1. Commitment:**
```
Prover:
- Choose random r
- Compute a₁ = g₁^r, a₂ = g₂^r
- Send (a₁, a₂) to Verifier
```

**2. Challenge:**
```
Verifier:
- Choose random c
- Send c to Prover
```

**3. Response:**
```
Prover:
- Compute z = r + c·x
- Send z to Verifier
```

**4. Verification:**
```
Verifier:
- Check g₁^z = a₁ · h₁^c
- Check g₂^z = a₂ · h₂^c
- Accept if both true
```

### Use Case: Discrete Log Equality

**Application:** Prove two ciphertexts encrypt the same message

```
ElGamal encryption:
C₁ = (g^r, m · h^r)
C₂ = (g^s, m · h^s)

Prove r = s without revealing r or m
```

### Implementation

```python
class ChaumPedersenProtocol:
    def __init__(self, g1, g2, h1, h2, q, x=None):
        self.g1 = g1
        self.g2 = g2
        self.h1 = h1  # g1^x
        self.h2 = h2  # g2^x
        self.q = q
        self.x = x
    
    def commit(self):
        """Prover: Generate commitments"""
        self.r = random.randint(1, self.q - 1)
        a1 = pow(self.g1, self.r, self.q)
        a2 = pow(self.g2, self.r, self.q)
        return (a1, a2)
    
    def challenge(self):
        """Verifier: Generate challenge"""
        c = random.randint(1, self.q - 1)
        return c
    
    def respond(self, c):
        """Prover: Compute response"""
        z = (self.r + c * self.x) % (self.q - 1)
        return z
    
    def verify(self, a1, a2, c, z):
        """Verifier: Verify proof"""
        check1 = pow(self.g1, z, self.q) == (a1 * pow(self.h1, c, self.q)) % self.q
        check2 = pow(self.g2, z, self.q) == (a2 * pow(self.h2, c, self.q)) % self.q
        return check1 and check2

# Example
q = 23
g1 = 5
g2 = 7
x = 9  # Secret

h1 = pow(g1, x, q)  # 5^9 mod 23
h2 = pow(g2, x, q)  # 7^9 mod 23

protocol = ChaumPedersenProtocol(g1, g2, h1, h2, q, x)

# Run protocol
a1, a2 = protocol.commit()
c = protocol.challenge()
z = protocol.respond(c)
is_valid = protocol.verify(a1, a2, c, z)

print(f"Proof valid: {is_valid}")
```

## Graph Isomorphism Protocol

### The Problem

**Graph Isomorphism:**
```
Given two graphs G₀ and G₁
Determine if they are isomorphic (same structure, different labeling)

This is believed to be hard but not NP-complete
```

**Zero-Knowledge Proof:**
```
Prover knows isomorphism π: G₀ → G₁
Prove knowledge without revealing π
```

### The Protocol

**Setup:**
```
Public: Graphs G₀ and G₁
Secret: Isomorphism π such that π(G₀) = G₁
```

**Protocol (one round):**

**1. Commitment:**
```
Prover:
- Choose random permutation σ
- Compute H = σ(G₀)
- Send H to Verifier
```

**2. Challenge:**
```
Verifier:
- Choose random bit b ∈ {0, 1}
- Send b to Prover
```

**3. Response:**
```
Prover:
If b = 0:
    - Send τ = σ
    - Verifier checks: τ(G₀) = H

If b = 1:
    - Send τ = σ ∘ π
    - Verifier checks: τ(G₁) = H
```

### Security Analysis

**Completeness:**
```
If Prover knows π:
- Can always respond correctly to either challenge
- Verifier always accepts
```

**Soundness:**
```
If Prover doesn't know π:
- Can prepare for either b=0 or b=1, but not both
- Probability of guessing correct b: 1/2
- After n rounds: (1/2)^n probability of cheating
```

**Zero-Knowledge:**
```
Simulator:
1. Guess b ∈ {0, 1}
2. If b = 0: H = σ(G₀), τ = σ
3. If b = 1: H = σ(G₁), τ = σ
4. If guess wrong, restart

Expected 2 attempts per round
Output distribution identical to real protocol
```

## Fiat-Shamir Transform

### Making Proofs Non-Interactive

**Problem:**
```
Interactive proofs require back-and-forth communication
Not suitable for blockchain or offline verification
```

**Solution:**
```
Replace verifier's random challenge with hash of commitment

Interactive:
Prover → Commitment → Verifier
Verifier → Challenge → Prover

Non-Interactive:
Prover computes Challenge = Hash(Commitment, Statement)
Prover sends (Commitment, Response)
Verifier recomputes Challenge and verifies
```

### Schnorr Signature (Fiat-Shamir Applied)

**Signing:**
```
Message: m
Secret key: x
Public key: h = g^x

1. Choose random r
2. Compute a = g^r
3. Compute c = Hash(a || m)  ← Fiat-Shamir
4. Compute z = r + c·x
5. Signature: (c, z)
```

**Verification:**
```
1. Compute a' = g^z · h^(-c)
2. Compute c' = Hash(a' || m)
3. Check c' = c
```

### Implementation

```python
def schnorr_sign(message, x, g, q):
    """Sign message using Schnorr signature"""
    # Commitment
    r = random.randint(1, q - 1)
    a = pow(g, r, q)
    
    # Challenge (Fiat-Shamir)
    c = int(sha256(f"{a}{message}".encode()).hexdigest(), 16) % q
    
    # Response
    z = (r + c * x) % (q - 1)
    
    return (c, z)

def schnorr_verify(message, signature, h, g, q):
    """Verify Schnorr signature"""
    c, z = signature
    
    # Recompute commitment
    a = (pow(g, z, q) * pow(h, -c, q)) % q
    
    # Recompute challenge
    c_prime = int(sha256(f"{a}{message}".encode()).hexdigest(), 16) % q
    
    return c == c_prime

# Example
q = 2**256 - 2**32 - 977  # Large prime
g = 5
x = random.randint(1, q - 1)  # Secret key
h = pow(g, x, q)  # Public key

message = "Hello, World!"
signature = schnorr_sign(message, x, g, q)
is_valid = schnorr_verify(message, signature, h, g, q)

print(f"Signature valid: {is_valid}")
```

### Security Considerations

**Random Oracle Model:**
```
Fiat-Shamir is secure in the Random Oracle Model
Assumes hash function behaves like truly random function

In practice:
- Use cryptographic hash (SHA-256, SHA-3)
- Include all public parameters in hash
- Ensure hash output is unpredictable
```

**Weak Fiat-Shamir:**
```
Bad: c = Hash(a)
- Doesn't bind to statement
- Allows proof reuse

Good: c = Hash(a || statement || public_params)
- Binds proof to specific statement
- Prevents malleability
```

## OR Proofs

### The Problem

**Goal:** Prove "I know x₀ OR x₁" without revealing which one

**Applications:**
```
- Ring signatures
- Anonymous credentials
- Deniable authentication
```

### OR Proof Construction

**Statement:** Know x such that h₀ = g^x OR h₁ = g^x

**Protocol:**

**Prover knows x₀ (h₀ = g^x₀):**

**1. Commitment:**
```
Real branch (0):
- Choose random r₀
- Compute a₀ = g^r₀

Simulated branch (1):
- Choose random c₁, z₁
- Compute a₁ = g^z₁ · h₁^(-c₁)

Send (a₀, a₁) to Verifier
```

**2. Challenge:**
```
Verifier sends random c
```

**3. Response:**
```
Prover:
- Set c₀ = c - c₁ mod q
- Compute z₀ = r₀ + c₀·x₀
- Send (c₀, z₀, c₁, z₁)
```

**4. Verification:**
```
Verifier checks:
- c₀ + c₁ = c mod q
- g^z₀ = a₀ · h₀^c₀
- g^z₁ = a₁ · h₁^c₁
```

### Security

**Zero-Knowledge:**
```
Verifier cannot tell which branch is real
Both branches look identical
Simulated branch is indistinguishable from real
```

**Soundness:**
```
Prover must know at least one discrete log
Cannot simulate both branches for same challenge
```

### Implementation

```python
class ORProof:
    def __init__(self, g, h0, h1, q, x0=None, x1=None):
        self.g = g
        self.h0 = h0
        self.h1 = h1
        self.q = q
        self.x0 = x0  # Know either x0 or x1
        self.x1 = x1
    
    def prove(self):
        """Generate OR proof"""
        if self.x0 is not None:
            # Know x0, simulate x1
            return self._prove_branch(0, self.x0)
        else:
            # Know x1, simulate x0
            return self._prove_branch(1, self.x1)
    
    def _prove_branch(self, real_branch, x):
        """Prove knowing one branch"""
        # Real branch
        r = random.randint(1, self.q - 1)
        
        if real_branch == 0:
            a0 = pow(self.g, r, self.q)
            # Simulate branch 1
            c1 = random.randint(1, self.q - 1)
            z1 = random.randint(1, self.q - 1)
            a1 = (pow(self.g, z1, self.q) * 
                  pow(self.h1, -c1, self.q)) % self.q
        else:
            a1 = pow(self.g, r, self.q)
            # Simulate branch 0
            c0 = random.randint(1, self.q - 1)
            z0 = random.randint(1, self.q - 1)
            a0 = (pow(self.g, z0, self.q) * 
                  pow(self.h0, -c0, self.q)) % self.q
        
        # Challenge (Fiat-Shamir)
        c = int(sha256(f"{a0}{a1}".encode()).hexdigest(), 16) % self.q
        
        # Complete real branch
        if real_branch == 0:
            c0 = (c - c1) % self.q
            z0 = (r + c0 * x) % (self.q - 1)
        else:
            c1 = (c - c0) % self.q
            z1 = (r + c1 * x) % (self.q - 1)
        
        return (a0, a1, c0, z0, c1, z1)
    
    def verify(self, proof):
        """Verify OR proof"""
        a0, a1, c0, z0, c1, z1 = proof
        
        # Recompute challenge
        c = int(sha256(f"{a0}{a1}".encode()).hexdigest(), 16) % self.q
        
        # Check challenge sum
        if (c0 + c1) % self.q != c:
            return False
        
        # Check both branches
        check0 = pow(self.g, z0, self.q) == (a0 * pow(self.h0, c0, self.q)) % self.q
        check1 = pow(self.g, z1, self.q) == (a1 * pow(self.h1, c1, self.q)) % self.q
        
        return check0 and check1

# Example
q = 23
g = 5
x0 = 7  # Know this
x1 = None  # Don't know this

h0 = pow(g, x0, q)
h1 = pow(g, 11, q)  # Some other value

prover = ORProof(g, h0, h1, q, x0=x0)
proof = prover.prove()

verifier = ORProof(g, h0, h1, q)
is_valid = verifier.verify(proof)

print(f"OR proof valid: {is_valid}")
```

## Range Proofs

### The Problem

**Goal:** Prove value v is in range [0, 2^n) without revealing v

**Applications:**
```
- Confidential transactions (prove amount > 0)
- Age verification (prove age ≥ 18)
- Credit scores (prove score > threshold)
```

### Bulletproofs

**Idea:** Prove v ∈ [0, 2^n) by proving v has n-bit binary representation

**Protocol Overview:**
```
1. Commit to value: C = g^v · h^r
2. Prove v = Σ v_i · 2^i where v_i ∈ {0, 1}
3. Use inner product argument for efficiency
```

**Properties:**
```
Proof size: O(log n) group elements
Verification: O(n) operations
No trusted setup
Aggregatable (batch multiple range proofs)
```

**Comparison:**
```
Naive approach: n separate proofs for each bit
Size: O(n)

Bulletproofs: Logarithmic size
Size: O(log n)

For 64-bit range:
Naive: 64 proofs
Bulletproofs: ~10 group elements
```

## Conclusion

Interactive zero-knowledge proofs form the foundation of modern ZKP systems. Sigma protocols like Schnorr and Chaum-Pedersen provide efficient proofs of knowledge for discrete logarithm relations. The Fiat-Shamir transform converts these interactive proofs into non-interactive signatures and proofs suitable for blockchain applications. OR proofs and range proofs extend the basic techniques to more complex statements, enabling applications like ring signatures and confidential transactions.

---

*Next: zk-SNARKs*
