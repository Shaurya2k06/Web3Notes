# Zero-Knowledge Proof Applications

## Overview

Zero-knowledge proofs have numerous practical applications in blockchain, privacy, identity, and beyond. This document explores real-world use cases and implementations.

## Blockchain Scaling (Layer 2)

### zkRollups

**Concept:**
```
Execute transactions off-chain
Generate ZK proof of correct execution
Post proof + state diff to Layer 1
Verify proof on-chain (cheap)
```

**Benefits:**
```
Throughput: 2000-10,000+ TPS
Cost: 1/100 to 1/1000 of L1
Security: Inherits L1 security
Finality: Minutes (proof generation time)
```

### zkSync

**Architecture:**
```
Layer: Ethereum L2
Technology: zk-SNARKs (PLONK)
Language: Solidity (EVM compatible)
Throughput: 2000+ TPS
```

**Transaction Flow:**
```
1. User submits transaction to zkSync
2. Operator batches transactions
3. Executes transactions off-chain
4. Generates SNARK proof
5. Submits proof + state diff to Ethereum
6. Ethereum verifies proof (5M gas)
7. State update finalized
```

**Cost Savings:**
```
Ethereum L1:
- Simple transfer: $5-50
- Uniswap swap: $50-200
- NFT mint: $100-500

zkSync L2:
- Simple transfer: $0.10-0.50
- Uniswap swap: $0.50-2
- NFT mint: $1-5

Improvement: 50-100x cheaper
```

**Code Example:**
```typescript
import { Wallet, Provider } from "zksync-web3";
import { ethers } from "ethers";

// Connect to zkSync
const provider = new Provider("https://zksync2-testnet.zksync.dev");
const wallet = new Wallet(privateKey, provider);

// Transfer tokens
const tx = await wallet.transfer({
    to: recipientAddress,
    amount: ethers.utils.parseEther("0.1"),
    token: "ETH"
});

await tx.wait();
console.log(`Transaction hash: ${tx.hash}`);
```

### StarkNet

**Architecture:**
```
Layer: Ethereum L2
Technology: zk-STARKs
Language: Cairo
Throughput: 10,000+ TPS
```

**Advantages:**
```
✓ No trusted setup
✓ Post-quantum secure
✓ Transparent
✓ Better for very large computations

Disadvantages:
✗ Larger proofs (~100 KB vs 200 bytes)
✗ Longer proving time
✗ New language (Cairo)
```

**Cairo Contract:**
```cairo
%lang starknet

from starkware.cairo.common.cairo_builtins import HashBuiltin

@storage_var
func balances(account: felt) -> (balance: felt) {
}

@external
func transfer{
    syscall_ptr: felt*,
    pedersen_ptr: HashBuiltin*,
    range_check_ptr
}(recipient: felt, amount: felt) {
    // Get sender balance
    let (sender_balance) = balances.read(account=msg.sender);
    assert_nn_le(amount, sender_balance);
    
    // Update balances
    balances.write(account=msg.sender, value=sender_balance - amount);
    
    let (recipient_balance) = balances.read(account=recipient);
    balances.write(account=recipient, value=recipient_balance + amount);
    
    return ();
}
```

### Polygon zkEVM

**Architecture:**
```
Layer: Ethereum L2
Technology: zk-SNARKs (PLONK)
Language: Solidity (full EVM equivalence)
Throughput: 2000+ TPS
```

**Key Feature: EVM Equivalence**
```
Not just EVM compatible, but EVM equivalent
- Same opcodes
- Same gas costs
- Same behavior
- Existing contracts work without modification

Benefit: Easy migration from Ethereum
```

## Privacy-Preserving Transactions

### Zcash

**Overview:**
```
First major cryptocurrency using zk-SNARKs
Optional privacy (transparent or shielded)
Hides sender, receiver, and amount
```

**Transaction Types:**
```
1. Transparent → Transparent (public, like Bitcoin)
2. Transparent → Shielded (deposit to private pool)
3. Shielded → Shielded (fully private)
4. Shielded → Transparent (withdraw from private pool)
```

**Shielded Transaction:**
```
Public information:
- Transaction occurred
- Nullifier (prevents double-spend)
- Commitment (new note created)

Hidden information:
- Sender address
- Receiver address
- Amount transferred
```

**Circuit (Simplified):**
```
Inputs (Private):
- Old note (value, owner, randomness)
- Spending key
- New note (value, owner, randomness)
- Merkle path (proves old note exists)

Inputs (Public):
- Merkle root
- Nullifier
- New note commitment

Constraints:
1. Old note is in Merkle tree
2. Spending key matches old note owner
3. Nullifier = Hash(old note, spending key)
4. New commitment = Hash(new note)
5. Values balance (old value = new value)
```

**Implementation:**
```rust
// Simplified Zcash note
struct Note {
    value: u64,
    owner: PublicKey,
    randomness: [u8; 32],
}

impl Note {
    fn commitment(&self) -> [u8; 32] {
        // Pedersen commitment
        let cm = pedersen_hash(&[
            &self.value.to_le_bytes(),
            &self.owner.to_bytes(),
            &self.randomness,
        ]);
        cm
    }
    
    fn nullifier(&self, spending_key: &PrivateKey) -> [u8; 32] {
        // Nullifier prevents double-spending
        let nf = prf_nf(spending_key, &self.commitment());
        nf
    }
}

// Spend note
fn spend_note(
    note: &Note,
    spending_key: &PrivateKey,
    merkle_path: &MerklePath,
) -> Transaction {
    // Generate nullifier
    let nullifier = note.nullifier(spending_key);
    
    // Create new note
    let new_note = Note {
        value: note.value,
        owner: recipient_key,
        randomness: random_bytes(),
    };
    
    // Generate proof
    let proof = generate_proof(
        note,
        spending_key,
        &new_note,
        merkle_path,
    );
    
    Transaction {
        nullifier,
        commitment: new_note.commitment(),
        proof,
    }
}
```

### Tornado Cash

**Overview:**
```
Privacy mixer for Ethereum
Breaks link between deposit and withdrawal
Uses zk-SNARKs (Groth16)
```

**How It Works:**
```
1. Deposit:
   - Generate secret (nullifier + randomness)
   - Compute commitment = Hash(nullifier, randomness)
   - Deposit ETH + commitment to contract
   - Commitment added to Merkle tree

2. Wait (break timing analysis)

3. Withdraw:
   - Prove knowledge of secret for commitment in tree
   - Provide nullifier (prevents double-withdraw)
   - Withdraw to different address
   - No link between deposit and withdrawal addresses
```

**Circuit:**
```
Inputs (Private):
- Nullifier
- Randomness
- Merkle path

Inputs (Public):
- Merkle root
- Nullifier hash
- Recipient address

Constraints:
1. Commitment = Hash(nullifier, randomness)
2. Commitment is in Merkle tree (verify path)
3. Nullifier hash = Hash(nullifier)
```

**Smart Contract:**
```solidity
contract TornadoCash {
    mapping(bytes32 => bool) public commitments;
    mapping(bytes32 => bool) public nullifierHashes;
    bytes32 public merkleRoot;
    
    function deposit(bytes32 commitment) external payable {
        require(msg.value == denomination, "Wrong amount");
        require(!commitments[commitment], "Commitment exists");
        
        commitments[commitment] = true;
        // Update Merkle tree
        updateMerkleTree(commitment);
    }
    
    function withdraw(
        bytes calldata proof,
        bytes32 nullifierHash,
        address payable recipient
    ) external {
        require(!nullifierHashes[nullifierHash], "Already withdrawn");
        require(verifyProof(proof, merkleRoot, nullifierHash, recipient), "Invalid proof");
        
        nullifierHashes[nullifierHash] = true;
        recipient.transfer(denomination);
    }
}
```

## Identity and Credentials

### Proof of Humanity

**Goal:** Prove you're a unique human without revealing identity

**Use Cases:**
```
- Sybil resistance
- Fair airdrops
- Democratic voting
- Universal Basic Income (UBI)
```

**Approach:**
```
1. Registration:
   - Submit biometric data (face scan, fingerprint)
   - Data hashed and stored in registry
   - Receive credential

2. Proof:
   - Prove biometric hash is in registry
   - Generate unique nullifier (one per context)
   - Don't reveal which registry entry

3. Verification:
   - Check proof is valid
   - Check nullifier not used before
   - Accept as unique human
```

**Circuit:**
```
Inputs (Private):
- Biometric hash
- Merkle path (proves in registry)
- Secret (for nullifier)

Inputs (Public):
- Registry Merkle root
- Nullifier
- Context (app/service identifier)

Constraints:
1. Biometric hash is in registry
2. Nullifier = Hash(biometric hash, secret, context)
3. Nullifier is unique per context
```

### Educational Credentials

**Goal:** Prove you have a degree without revealing details

**Example:**
```
Prove: "I have a CS degree from MIT"
Without revealing:
- Graduation year
- GPA
- Student ID
- Exact degree details
```

**Circuit:**
```
Inputs (Private):
- Credential (degree, university, year, GPA, etc.)
- University signature
- Merkle path (credential in university registry)

Inputs (Public):
- University public key
- Claim: "CS degree from MIT"
- Nullifier (prevents reuse)

Constraints:
1. Credential is signed by university
2. Credential is in university registry
3. Credential matches claim
4. Nullifier = Hash(credential, context)
```

**Benefits:**
```
- Privacy: Don't reveal unnecessary details
- Verifiability: Cryptographically proven
- Portability: Use across platforms
- Revocability: University can revoke if needed
```

## DeFi Applications

### Private Trading

**Problem:**
```
Public blockchains reveal:
- Trading strategies
- Portfolio composition
- Entry/exit points
- Account balances

This enables:
- Front-running
- Sandwich attacks
- Copycat trading
- Targeted attacks
```

**Solution: ZK Trading**
```
Prove: "I have sufficient balance for trade"
Without revealing:
- Exact balance
- Trading history
- Portfolio composition
```

**Circuit:**
```
Inputs (Private):
- Account balance
- Trade amount
- Account Merkle path

Inputs (Public):
- Exchange Merkle root
- Trade commitment
- Nullifier

Constraints:
1. Account is in exchange registry
2. Balance ≥ trade amount
3. Trade commitment = Hash(trade details)
4. Nullifier prevents double-spend
```

**Example: Penumbra**
```
Private DEX on Cosmos
Uses zk-SNARKs
Hides:
- Trading amounts
- Asset types
- Account balances

Shows:
- Trades occurred
- Trades are valid
```

### Undercollateralized Lending

**Problem:**
```
DeFi lending requires overcollateralization
- Deposit $150 to borrow $100
- Capital inefficient
- Excludes many users
```

**Solution: ZK Credit Scores**
```
Prove: "I have good credit score"
Without revealing:
- Income
- Assets
- Identity
- Credit history details
```

**Circuit:**
```
Inputs (Private):
- Credit score
- Credit bureau signature
- Income
- Debt-to-income ratio

Inputs (Public):
- Credit bureau public key
- Minimum score threshold
- Loan amount

Constraints:
1. Credit score is signed by bureau
2. Score ≥ threshold
3. Debt-to-income ratio acceptable
4. Income sufficient for loan
```

**Benefits:**
```
- Access to credit for more users
- Privacy preserved
- Lower collateral requirements
- Regulatory compliance possible
```

### Compliant DeFi

**Goal:** Prove compliance without revealing details

**KYC/AML:**
```
Prove: "I passed KYC"
Without revealing:
- Name
- Address
- ID number
- Date of birth
```

**Accredited Investor:**
```
Prove: "I'm an accredited investor"
Without revealing:
- Net worth
- Income
- Assets
```

**Sanctions Screening:**
```
Prove: "I'm not on sanctions list"
Without revealing:
- Identity
- Location
- Transaction history
```

**Circuit:**
```
Inputs (Private):
- KYC data
- Compliance provider signature
- User attributes

Inputs (Public):
- Compliance provider public key
- Requirements (age > 18, accredited, etc.)
- Nullifier

Constraints:
1. KYC data is signed by provider
2. User meets requirements
3. Not on sanctions list
4. Nullifier for privacy
```

## Voting Systems

### Private Voting

**Requirements:**
```
1. Eligibility: Only registered voters can vote
2. Privacy: Vote choice is secret
3. Verifiability: Can verify vote was counted
4. No double-voting: Each voter votes once
5. Coercion resistance: Cannot prove how you voted
```

**ZK Voting Protocol:**
```
1. Registration:
   - Voter registers with credential
   - Receives voting token

2. Voting:
   - Encrypt vote
   - Generate ZK proof:
     * I have valid voting token
     * Vote is for valid candidate
     * Token not used before
   - Submit encrypted vote + proof

3. Tallying:
   - Decrypt all votes (threshold decryption)
   - Count votes
   - Publish results
```

**Circuit:**
```
Inputs (Private):
- Voting token
- Vote choice
- Randomness

Inputs (Public):
- Voter registry Merkle root
- Encrypted vote
- Nullifier

Constraints:
1. Token is in voter registry
2. Vote is for valid candidate
3. Encrypted vote = Encrypt(vote, randomness)
4. Nullifier = Hash(token)
5. Nullifier not used before
```

**Example: MACI (Minimal Anti-Collusion Infrastructure)**
```
Uses zk-SNARKs
Prevents bribery and coercion
Coordinator cannot see individual votes
Voters can change vote (last one counts)
```

## Supply Chain

### Provenance Tracking

**Goal:** Prove product authenticity without revealing supply chain details

**Use Case: Luxury Goods**
```
Prove: "This bag is authentic Louis Vuitton"
Without revealing:
- Manufacturing location
- Supplier identities
- Production costs
- Distribution channels
```

**Circuit:**
```
Inputs (Private):
- Manufacturing record
- Supplier signatures
- Production details
- Distribution path

Inputs (Public):
- Brand public key
- Product ID
- Authenticity claim

Constraints:
1. Manufacturing record signed by brand
2. All suppliers in approved list
3. Production meets standards
4. Distribution path valid
5. Product ID matches record
```

### Ethical Sourcing

**Goal:** Prove ethical sourcing without revealing suppliers

**Example: Conflict-Free Diamonds**
```
Prove: "This diamond is conflict-free"
Without revealing:
- Mine location
- Supplier identities
- Purchase prices
- Distribution network
```

**Benefits:**
```
- Protect supplier privacy
- Prevent competitor intelligence
- Maintain ethical standards
- Enable verification
```

## Healthcare

### Medical Records

**Goal:** Prove medical facts without revealing full records

**Use Cases:**
```
1. Insurance:
   Prove: "I don't have pre-existing condition X"
   Without revealing: Full medical history

2. Clinical Trials:
   Prove: "I meet trial criteria"
   Without revealing: Specific conditions

3. Prescriptions:
   Prove: "I have valid prescription"
   Without revealing: Medical condition
```

**Circuit:**
```
Inputs (Private):
- Medical record
- Doctor signature
- Specific conditions

Inputs (Public):
- Hospital public key
- Claim (e.g., "no condition X")
- Timestamp

Constraints:
1. Record signed by doctor
2. Doctor authorized by hospital
3. Claim matches record
4. Record is recent
```

## Gaming

### Provably Fair Games

**Goal:** Prove game outcome is fair without revealing game state

**Poker Example:**
```
Prove: "I have a royal flush"
Without revealing:
- Exact cards
- Other players' cards
- Deck order
```

**Circuit:**
```
Inputs (Private):
- Player's cards
- Deck shuffle seed
- Card positions

Inputs (Public):
- Deck commitment
- Hand ranking claim

Constraints:
1. Cards are from committed deck
2. No duplicate cards
3. Hand ranking is correct
4. Shuffle was random
```

### Anti-Cheat

**Goal:** Prove player actions are legitimate

**Example: FPS Game**
```
Prove: "My aim is human, not aimbot"
Without revealing:
- Exact mouse movements
- Reaction times
- Game state details
```

**Circuit:**
```
Inputs (Private):
- Mouse movement data
- Reaction time statistics
- Aim accuracy metrics

Inputs (Public):
- Player ID
- Game session
- Legitimacy claim

Constraints:
1. Mouse movements within human range
2. Reaction times realistic
3. Accuracy not superhuman
4. No impossible shots
```

## Conclusion

Zero-knowledge proofs enable a wide range of applications across blockchain, privacy, identity, finance, and beyond. They provide the unique ability to prove statements without revealing underlying data, opening up new possibilities for privacy-preserving systems. As ZKP technology matures and becomes more accessible, we'll see even more innovative applications emerge.

---

*Next: ZKP Security and Best Practices*
