# zk-STARKs: Zero-Knowledge Scalable Transparent Arguments of Knowledge

## Overview

zk-STARKs are a newer family of zero-knowledge proofs that address some limitations of zk-SNARKs. They offer transparency (no trusted setup), post-quantum security, and better scalability for very large computations.

## What is a zk-STARK?

**Acronym Breakdown:**
```
zk: Zero-Knowledge
    - Verifier learns nothing except validity

S: Scalable
    - Prover time scales quasi-linearly: O(n log n)
    - Better than SNARKs for very large computations

T: Transparent
    - No trusted setup required
    - Only public randomness needed

AR: Argument
    - Computationally sound

K: of Knowledge
    - Proves knowledge of witness
```

## Key Differences from zk-SNARKs

| Feature | zk-SNARKs | zk-STARKs |
|---------|-----------|-----------|
| Proof Size | ~200 bytes | ~100-200 KB |
| Verification Time | ~10ms | ~10-50ms |
| Proving Time | O(n log n) | O(n log² n) |
| Trusted Setup | Required | Not required |
| Quantum Security | No | Yes |
| Cryptographic Assumptions | Strong (pairings) | Weak (hash functions) |
| Maturity | More mature | Newer |

## Mathematical Foundations

### Finite Fields

**STARKs work over large finite fields:**
```
F_p where p is a large prime (typically 2^64 - 2^32 + 1)

Example: Goldilocks field
p = 2^64 - 2^32 + 1
  = 18446744069414584321

Properties:
- Fast arithmetic (64-bit operations)
- FFT-friendly (has large multiplicative subgroup)
- Efficient implementation
```

### Polynomial Commitment: FRI

**Fast Reed-Solomon Interactive Oracle Proof of Proximity (FRI)**

**Goal:** Prove a function is "close" to a low-degree polynomial

**Why it matters:**
```
If prover can evaluate polynomial at many points,
and these evaluations are consistent with low-degree polynomial,
then prover knows the polynomial.

This is the core of STARK security.
```

**FRI Protocol Overview:**
```
1. Prover commits to polynomial evaluations
2. Verifier sends random challenge
3. Prover "folds" polynomial (reduces degree by half)
4. Repeat until polynomial is constant
5. Verifier checks consistency
```

**Folding Step:**
```
Polynomial: f(x) of degree d

Split into even and odd coefficients:
f(x) = f_even(x²) + x · f_odd(x²)

Fold with random α:
f_next(x) = f_even(x) + α · f_odd(x)

Degree reduced: d → d/2
```

**Example:**
```
f(x) = a₀ + a₁x + a₂x² + a₃x³

Even part: f_even(x) = a₀ + a₂x
Odd part: f_odd(x) = a₁ + a₃x

f(x) = f_even(x²) + x · f_odd(x²)

With challenge α:
f_next(x) = f_even(x) + α · f_odd(x)
          = (a₀ + a₂x) + α(a₁ + a₃x)
          = (a₀ + αa₁) + (a₂ + αa₃)x

Degree: 3 → 1 (reduced by half)
```

## The STARK Pipeline

### 1. Computation → Algebraic Intermediate Representation (AIR)

**AIR Constraints:**
```
Express computation as polynomial constraints over execution trace

Execution trace: Matrix of values
- Rows: Time steps
- Columns: Registers/variables

Constraints: Polynomials that must equal zero
```

**Example: Fibonacci Sequence**
```
Computation:
a₀ = 1
a₁ = 1
aᵢ = aᵢ₋₁ + aᵢ₋₂ for i ≥ 2

Execution Trace:
Step | a | b
-----|---|---
  0  | 1 | 1
  1  | 1 | 2
  2  | 2 | 3
  3  | 3 | 5
  4  | 5 | 8

Constraints:
1. Boundary: a₀ = 1, b₀ = 1
2. Transition: aᵢ₊₁ = bᵢ
3. Transition: bᵢ₊₁ = aᵢ + bᵢ
```

**Polynomial Constraints:**
```
For each row i:
P₁(aᵢ, bᵢ, aᵢ₊₁, bᵢ₊₁) = aᵢ₊₁ - bᵢ = 0
P₂(aᵢ, bᵢ, aᵢ₊₁, bᵢ₊₁) = bᵢ₊₁ - aᵢ - bᵢ = 0

These must hold for all rows
```

### 2. Execution Trace → Polynomial

**Interpolation:**
```
Convert trace columns to polynomials

Column a: [1, 1, 2, 3, 5, ...]
Interpolate polynomial A(x) through points:
(ω⁰, 1), (ω¹, 1), (ω², 2), (ω³, 3), (ω⁴, 5), ...

Where ω is a root of unity
```

**Low-Degree Extension (LDE):**
```
Evaluate polynomial on larger domain

Original domain: n points
Extended domain: k·n points (typically k = 8 or 16)

Why? Enables error detection
If polynomial has degree d, but evaluations don't match,
can detect with high probability
```

### 3. Constraints → Composition Polynomial

**Combine all constraints:**
```
C(x) = Σ αᵢ · Pᵢ(x) / Zᵢ(x)

Where:
- Pᵢ(x) = constraint polynomial
- Zᵢ(x) = zerofier (vanishes where constraint should hold)
- αᵢ = random challenge (for soundness)
```

**Zerofier:**
```
Z(x) = Π (x - ωⁱ) for i in constraint domain

Example: Constraint holds at ω⁰, ω¹, ω²
Z(x) = (x - ω⁰)(x - ω¹)(x - ω²)

Z(ωⁱ) = 0 for i ∈ {0, 1, 2}
```

**Property:**
```
If all constraints satisfied:
C(x) is a polynomial (no poles)

If any constraint violated:
C(x) has poles (not a polynomial)
```

### 4. FRI Proof

**Prove C(x) is low-degree:**
```
1. Commit to C(x) evaluations (Merkle tree)
2. Run FRI protocol
3. Fold polynomial log(d) times
4. Verify final polynomial is constant
```

**Merkle Commitment:**
```
Evaluations: [C(x₀), C(x₁), ..., C(xₙ)]

Build Merkle tree:
        Root
       /    \
      H₁₂   H₃₄
     /  \   /  \
    H₁  H₂ H₃  H₄
    |   |  |   |
   C(x₀) C(x₁) C(x₂) C(x₃)

Commit to root
```

## STARK Proof Structure

**Components:**
```
1. Execution trace commitment (Merkle root)
2. Composition polynomial commitment
3. FRI commitments (one per folding round)
4. FRI query proofs (Merkle paths)
5. Out-of-domain samples

Total size: ~100-200 KB (depends on security parameter)
```

**Size Breakdown:**
```
Merkle roots: ~32 bytes each × log(n) rounds = ~1 KB
FRI queries: ~1 KB per query × 20-40 queries = 20-40 KB
Polynomial evaluations: ~32 bytes × queries × rounds = 50-100 KB
Authentication paths: ~32 bytes × depth × queries = 20-40 KB

Total: ~100-200 KB
```

## Verification

**Verifier Steps:**
```
1. Recompute composition polynomial at random points
2. Check FRI consistency
3. Verify Merkle proofs
4. Check boundary conditions
5. Accept if all checks pass
```

**Verification Time:**
```
Dominated by:
- Hash computations (Merkle proofs)
- Field arithmetic (polynomial evaluations)

Typical: 10-50ms for 1M-10M constraints
Scales logarithmically with computation size
```

## Cairo: The STARK-Friendly Language

### Overview

**Cairo** is a programming language designed for writing provable programs for STARKs.

**Key Features:**
```
- Turing-complete
- Memory-based (not register-based)
- Immutable memory
- Non-deterministic hints
- Efficient STARK generation
```

### Cairo Syntax

**Basic Program:**
```cairo
%builtins output

from starkware.cairo.common.serialize import serialize_word

func main{output_ptr: felt*}() {
    // Compute 1 + 2
    tempvar x = 1 + 2;
    
    // Output result
    serialize_word(x);
    
    return ();
}
```

**Fibonacci Example:**
```cairo
func fib(n: felt) -> felt {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    let a = fib(n - 1);
    let b = fib(n - 2);
    return a + b;
}

func main{output_ptr: felt*}() {
    let result = fib(10);
    serialize_word(result);
    return ();
}
```

**Memory Model:**
```
Cairo uses continuous memory:
- Memory is write-once (immutable)
- Addresses are field elements
- Efficient for STARK proving

Example:
[ap] = 5;      // Write 5 to current address
[ap + 1] = 10; // Write 10 to next address
ap += 2;       // Advance pointer
```

### Non-Deterministic Hints

**Hints** allow efficient computation outside the provable execution:

```cairo
func sqrt(n: felt) -> felt {
    // Hint: Compute square root off-chain
    %{
        import math
        ids.result = int(math.sqrt(ids.n))
    %}
    
    // Verify result on-chain
    assert result * result == n;
    return result;
}
```

**Why hints?**
```
- Expensive operations done off-chain
- Only verification is proven
- Dramatically reduces proof size

Example: Finding square root
- Computing: Expensive in circuit
- Verifying: Cheap (just multiply)
```

## StarkNet: Layer 2 Using STARKs

### Architecture

**Components:**
```
1. Sequencer: Orders transactions
2. Prover: Generates STARK proofs
3. Verifier: On-chain contract (Ethereum)
4. State: Merkle tree of accounts
```

**Transaction Flow:**
```
1. User submits transaction to StarkNet
2. Sequencer includes in block
3. Prover generates STARK proof
4. Proof submitted to Ethereum
5. Ethereum verifies proof
6. State update accepted
```

**Scalability:**
```
Batch size: 10,000+ transactions
Proof generation: ~1 hour
Proof verification: ~5 million gas (~$50-100)
Cost per transaction: $0.005-0.01

Compare to Ethereum L1: $5-50 per transaction
Improvement: 1000x+
```

### Cairo Contracts

**Simple Contract:**
```cairo
%lang starknet

from starkware.cairo.common.cairo_builtins import HashBuiltin

@storage_var
func balance(user: felt) -> (res: felt) {
}

@external
func deposit{
    syscall_ptr: felt*,
    pedersen_ptr: HashBuiltin*,
    range_check_ptr
}(amount: felt) {
    let (current_balance) = balance.read(user=msg.sender);
    balance.write(user=msg.sender, value=current_balance + amount);
    return ();
}

@view
func get_balance{
    syscall_ptr: felt*,
    pedersen_ptr: HashBuiltin*,
    range_check_ptr
}(user: felt) -> (res: felt) {
    let (res) = balance.read(user=user);
    return (res=res);
}
```

## Recursive STARKs

### Concept

**Prove that you verified a proof:**
```
Instead of: Verify proof on-chain (expensive)
Do: Prove you verified proof (cheap)

Recursion: Proof of proof verification
```

**Benefits:**
```
1. Proof aggregation
   - Combine many proofs into one
   - Constant verification cost

2. Infinite scalability
   - Prove arbitrarily large computations
   - Verification always constant

3. Proof composition
   - Chain proofs together
   - Build complex systems
```

**Example:**
```
Layer 1: 1000 transactions → Proof P₁
Layer 2: 1000 transactions → Proof P₂
...
Layer N: 1000 transactions → Proof Pₙ

Recursive proof: Prove "I verified P₁, P₂, ..., Pₙ"
Result: Single proof for N×1000 transactions
```

### Implementation

**Verification Circuit:**
```
Input: Proof π, Public input x
Output: Accept/Reject

Circuit:
1. Parse proof π
2. Recompute challenges (Fiat-Shamir)
3. Verify FRI queries
4. Check Merkle proofs
5. Verify polynomial evaluations
6. Output 1 if all checks pass
```

**Recursive Proof:**
```
Prove: "I executed verification circuit correctly"

Input to recursive prover:
- Verification circuit
- Proof π
- Public input x

Output: Proof π' that verification succeeded

Verifier checks π' (constant cost)
```

## Practical Considerations

### Proof Size vs Security

**Trade-off:**
```
Higher security → Larger proofs
Lower security → Smaller proofs

Security parameter λ:
- λ = 80: ~80 KB proofs
- λ = 100: ~100 KB proofs
- λ = 128: ~150 KB proofs

Typical: λ = 100 (100 bits of security)
```

**Query Complexity:**
```
Number of FRI queries affects:
- Proof size (more queries = larger proof)
- Security (more queries = higher security)
- Verification time (more queries = slower)

Typical: 20-40 queries
```

### Proving Time

**Factors:**
```
1. Trace length (number of steps)
2. Trace width (number of columns)
3. Constraint complexity
4. LDE blowup factor
5. Hardware (CPU, RAM)
```

**Benchmarks:**
```
1M steps:
- Trace generation: ~1 second
- LDE: ~5 seconds
- FRI: ~10 seconds
- Total: ~20 seconds

10M steps:
- Trace generation: ~10 seconds
- LDE: ~1 minute
- FRI: ~2 minutes
- Total: ~3-4 minutes

100M steps:
- Total: ~30-40 minutes
```

**Hardware Requirements:**
```
Small proofs (< 1M steps):
- CPU: 8+ cores
- RAM: 16 GB

Medium proofs (1-10M steps):
- CPU: 32+ cores
- RAM: 64 GB

Large proofs (> 10M steps):
- CPU: 64+ cores
- RAM: 128+ GB
```

### Hash Functions

**STARKs use hash functions extensively:**
```
- Merkle trees
- Fiat-Shamir transform
- Commitment schemes
```

**Requirements:**
```
- Collision resistant
- Fast computation
- Suitable for field arithmetic
```

**Common Choices:**
```
Rescue: Algebraic hash, STARK-friendly
Poseidon: Efficient, widely used
Blake3: Fast, standard hash
Keccak: Ethereum-compatible
```

## Comparison: Use Cases

### When to Use zk-SNARKs

```
✓ Need smallest proofs (on-chain storage)
✓ Need fastest verification
✓ Computation is small-medium
✓ Can tolerate trusted setup
✓ Don't need quantum resistance

Examples:
- Private transactions (Zcash)
- Identity proofs
- Small circuits
```

### When to Use zk-STARKs

```
✓ Need transparency (no trusted setup)
✓ Need quantum resistance
✓ Computation is very large
✓ Can tolerate larger proofs
✓ Want simpler cryptographic assumptions

Examples:
- Layer 2 scaling (StarkNet)
- Computational integrity
- Large-scale proofs
- Long-term security
```

## Development Tools

### Stone Prover

**StarkWare's STARK prover:**
```bash
# Generate proof
cpu_air_prover \
    --out_file=proof.json \
    --private_input_file=private_input.json \
    --public_input_file=public_input.json \
    --prover_config_file=cpu_air_prover_config.json \
    --parameter_file=cpu_air_params.json

# Verify proof
cpu_air_verifier \
    --in_file=proof.json
```

### Cairo Toolchain

```bash
# Compile Cairo program
cairo-compile program.cairo --output program_compiled.json

# Run program
cairo-run \
    --program=program_compiled.json \
    --print_output \
    --layout=small

# Generate proof
cairo-run \
    --program=program_compiled.json \
    --proof_mode \
    --output=proof.json
```

### Winterfell (Rust)

```rust
use winterfell::{
    Air, AirContext, Assertion, EvaluationFrame,
    ProofOptions, Prover, Trace, TraceTable,
};

// Define AIR
struct FibAir {
    context: AirContext<Felt>,
}

impl Air for FibAir {
    fn evaluate_transition<E: FieldElement>(
        &self,
        frame: &EvaluationFrame<E>,
        _periodic_values: &[E],
        result: &mut [E],
    ) {
        // Constraint: a[i+1] = b[i]
        result[0] = frame.current()[0] - frame.next()[1];
        
        // Constraint: b[i+1] = a[i] + b[i]
        result[1] = frame.next()[1] - frame.current()[0] - frame.current()[1];
    }
}

// Generate proof
let trace = build_trace();
let prover = FibProver::new(options);
let proof = prover.prove(trace).unwrap();

// Verify proof
let result = winterfell::verify::<FibAir>(proof, pub_inputs);
```

## Security Analysis

### Soundness

**Soundness Error:**
```
Probability that prover can cheat:
ε ≈ (d/|F|)^q

Where:
- d = polynomial degree
- |F| = field size
- q = number of queries

Example:
d = 2^20
|F| = 2^64
q = 40

ε ≈ (2^20 / 2^64)^40 = 2^(-1760)

Negligible!
```

### Post-Quantum Security

**Why STARKs are quantum-resistant:**
```
Based on:
- Hash functions (collision resistance)
- Error-correcting codes (Reed-Solomon)

Quantum attacks:
- Grover's algorithm: √speedup (not breaking)
- No known efficient quantum attack

To maintain security:
- Double hash output size
- Increase query complexity slightly
```

## Conclusion

zk-STARKs offer transparency, post-quantum security, and excellent scalability for large computations. While they produce larger proofs than zk-SNARKs, they eliminate the need for trusted setups and rely on simpler cryptographic assumptions. STARKs are particularly well-suited for blockchain scaling solutions like StarkNet, where the benefits of transparency and quantum resistance outweigh the cost of larger proofs. Understanding the FRI protocol, AIR constraints, and Cairo programming is essential for building STARK-based applications.

---

*Next: ZKP Applications in Blockchain*
