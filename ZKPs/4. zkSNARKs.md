# zk-SNARKs: Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge

## Overview

zk-SNARKs are a family of zero-knowledge proof systems that produce short proofs that can be verified quickly. They are the most widely deployed ZKP technology in blockchain applications.

## What is a zk-SNARK?

**Acronym Breakdown:**
```
zk: Zero-Knowledge
    - Verifier learns nothing except validity

S: Succinct
    - Proofs are small (constant size, ~200 bytes)
    - Verification is fast (constant time, ~10ms)

N: Non-Interactive
    - Single message from prover to verifier
    - No back-and-forth communication

AR: Argument
    - Computationally sound (not information-theoretically)
    - Secure against polynomial-time adversaries

K: of Knowledge
    - Proves knowledge of witness, not just truth of statement
```

## Key Properties

**Proof Size:**
```
Constant: ~192-400 bytes regardless of computation size
Compare to:
- Computation: Gigabytes of data
- Proof: Few hundred bytes
- Compression ratio: 1,000,000:1 or more
```

**Verification Time:**
```
Constant: ~5-10ms regardless of computation size
Compare to:
- Re-executing computation: Minutes to hours
- Verifying proof: Milliseconds
- Speedup: 100,000x or more
```

**Proving Time:**
```
Linear to quasi-linear: O(n) to O(n log n)
Where n = size of computation

Example:
- 1M constraints: ~30 seconds
- 10M constraints: ~5 minutes
- 100M constraints: ~1 hour
```

## The zk-SNARK Pipeline

### 1. Computation → Arithmetic Circuit

**Transform computation into arithmetic circuit:**

```
Original Code:
function verify(a, b, c) {
    return a * b + c == 10
}

Arithmetic Circuit:
x = a * b
y = x + c
z = y - 10
assert z == 0
```

**Circuit Representation:**
```
Gates: Multiplication and addition
Wires: Carry values between gates
Constraints: Relationships between wires

Example:
Input wires: a, b, c
Intermediate: x, y
Output: z

Constraints:
1. x = a * b
2. y = x + c
3. z = y - 10
4. z = 0
```

### 2. Arithmetic Circuit → R1CS

**Rank-1 Constraint System (R1CS):**

**Format:**
```
(A · w) ∘ (B · w) = (C · w)

Where:
- w = witness vector (all wire values)
- A, B, C = constraint matrices
- ∘ = element-wise multiplication
```

**Example:**
```
Circuit: x = a * b

Witness: w = [1, a, b, x]
(1 is always first element)

Constraint:
A = [0, 1, 0, 0]  (selects a)
B = [0, 0, 1, 0]  (selects b)
C = [0, 0, 0, 1]  (selects x)

Check: a * b = x
```

**Full Example:**
```
Computation: (a + b) * c = d

Witness: w = [1, a, b, c, d, x]
where x = a + b

Constraint 1: x = a + b
A₁ = [0, 1, 1, 0, 0, 0]
B₁ = [1, 0, 0, 0, 0, 0]
C₁ = [0, 0, 0, 0, 0, 1]
(a + b) * 1 = x

Constraint 2: d = x * c
A₂ = [0, 0, 0, 0, 0, 1]
B₂ = [0, 0, 0, 1, 0, 0]
C₂ = [0, 0, 0, 0, 1, 0]
x * c = d
```

### 3. R1CS → QAP

**Quadratic Arithmetic Program (QAP):**

**Idea:** Convert R1CS matrices into polynomials

**Process:**
```
For each column of A, B, C matrices:
- Create polynomial through constraint points
- Use Lagrange interpolation

Result:
- A(x), B(x), C(x) = polynomials
- Target polynomial T(x)
```

**Property:**
```
If witness satisfies all constraints:
A(x) · B(x) - C(x) = H(x) · T(x)

Where:
- T(x) = target polynomial (encodes constraint points)
- H(x) = quotient polynomial
- Division is exact (no remainder)
```

**Example:**
```
3 constraints at points x = 1, 2, 3

For wire i:
- Values from A matrix: [a₁, a₂, a₃]
- Interpolate polynomial A_i(x) through points:
  (1, a₁), (2, a₂), (3, a₃)

Target polynomial:
T(x) = (x - 1)(x - 2)(x - 3)

Vanishes at constraint points
```

### 4. QAP → Proof

**Proving:**
```
1. Evaluate polynomials at secret point s
2. Compute A(s), B(s), C(s), H(s)
3. Create cryptographic commitments
4. Generate proof π
```

**Verification:**
```
1. Check pairing equation:
   e(A, B) = e(C, 1) · e(H, T)

2. If true, accept proof
```

## Groth16: The Most Efficient zk-SNARK

### Overview

**Properties:**
```
Proof size: 3 group elements (192 bytes)
Verification: 3 pairings + 1 multi-exponentiation
Setup: Trusted, circuit-specific
Security: Relies on pairing-friendly curves
```

**Use Cases:**
```
- Zcash (shielded transactions)
- Filecoin (proof of replication)
- Tornado Cash (privacy mixer)
- Early zkSync
```

### Trusted Setup

**The Ceremony:**
```
Goal: Generate proving key (pk) and verification key (vk)

Process:
1. Choose random toxic waste: τ, α, β, γ, δ
2. Compute public parameters using toxic waste
3. Destroy toxic waste
4. If toxic waste is known, can create fake proofs!
```

**Multi-Party Computation (MPC):**
```
Multiple participants contribute randomness
Only need 1 honest participant
Each adds their own randomness
Final toxic waste = product of all randomness

Example: Zcash Powers of Tau
- 6 ceremonies over the years
- 1000+ participants
- Elaborate security measures
- Destroyed computers, etc.
```

**Circuit-Specific:**
```
Each circuit needs its own setup
Change circuit → need new ceremony
Expensive and inconvenient
```

### Proof Generation

**Prover Algorithm:**

**Input:**
```
- Proving key pk
- Public input x
- Private witness w
```

**Steps:**
```
1. Compute wire values from witness
2. Evaluate polynomials at secret point
3. Compute proof elements:
   π_A = α + Σ a_i · A_i(τ) + r·δ
   π_B = β + Σ b_i · B_i(τ) + s·δ
   π_C = Σ c_i · C_i(τ) + h(τ)·t(τ)/δ + π_A·s + π_B·r - r·s·δ

4. Output proof: π = (π_A, π_B, π_C)
```

**Proof Size:**
```
π_A: 1 G₁ element (32 bytes)
π_B: 1 G₂ element (64 bytes)
π_C: 1 G₁ element (32 bytes)

Total: 128 bytes (compressed) or 192 bytes (uncompressed)
```

### Verification

**Verifier Algorithm:**

**Input:**
```
- Verification key vk
- Public input x
- Proof π = (π_A, π_B, π_C)
```

**Verification Equation:**
```
e(π_A, π_B) = e(α, β) · e(L, γ) · e(π_C, δ)

Where:
- e = pairing function
- L = linear combination of public inputs
- α, β, γ, δ from verification key
```

**Verification Time:**
```
3 pairings: ~10ms
1 multi-exponentiation: ~2ms
Total: ~12ms (constant, regardless of circuit size)
```

### Implementation Example

```python
# Simplified Groth16 (conceptual)
class Groth16:
    def __init__(self, circuit):
        self.circuit = circuit
        self.pk, self.vk = self.trusted_setup()
    
    def trusted_setup(self):
        """Generate proving and verification keys"""
        # Choose toxic waste (in practice, use MPC)
        tau = random_field_element()
        alpha = random_field_element()
        beta = random_field_element()
        gamma = random_field_element()
        delta = random_field_element()
        
        # Compute proving key
        pk = {
            'alpha': alpha * G1,
            'beta': beta * G1,
            'delta': delta * G1,
            'tau_powers': [tau**i * G1 for i in range(circuit.degree)],
            # ... more elements
        }
        
        # Compute verification key
        vk = {
            'alpha': alpha * G1,
            'beta': beta * G2,
            'gamma': gamma * G2,
            'delta': delta * G2,
            # ... more elements
        }
        
        # DESTROY toxic waste (critical!)
        del tau, alpha, beta, gamma, delta
        
        return pk, vk
    
    def prove(self, public_input, private_witness):
        """Generate proof"""
        # Compute all wire values
        wires = self.circuit.compute(public_input, private_witness)
        
        # Evaluate polynomials
        A_eval = self.evaluate_A(wires)
        B_eval = self.evaluate_B(wires)
        C_eval = self.evaluate_C(wires)
        H_eval = self.compute_H(A_eval, B_eval, C_eval)
        
        # Add randomness
        r = random_field_element()
        s = random_field_element()
        
        # Compute proof elements
        pi_A = self.pk['alpha'] + A_eval + r * self.pk['delta']
        pi_B = self.pk['beta'] + B_eval + s * self.pk['delta']
        pi_C = C_eval + H_eval + pi_A * s + pi_B * r - r * s * self.pk['delta']
        
        return (pi_A, pi_B, pi_C)
    
    def verify(self, public_input, proof):
        """Verify proof"""
        pi_A, pi_B, pi_C = proof
        
        # Compute linear combination of public inputs
        L = self.compute_public_input_linear_combination(public_input)
        
        # Check pairing equation
        left = pairing(pi_A, pi_B)
        right = (pairing(self.vk['alpha'], self.vk['beta']) *
                pairing(L, self.vk['gamma']) *
                pairing(pi_C, self.vk['delta']))
        
        return left == right
```

## PLONK: Universal zk-SNARK

### Overview

**Advantages over Groth16:**
```
✓ Universal setup (one-time, reusable)
✓ Updatable setup (can add randomness later)
✓ Custom gates (more expressive)
✓ Simpler circuit design

Disadvantages:
✗ Larger proofs (~400 bytes vs 192 bytes)
✗ Slightly slower verification
```

**Use Cases:**
```
- zkSync 2.0
- Aztec Protocol
- Mina Protocol
- Polygon zkEVM
```

### Universal Setup

**Powers of Tau:**
```
One-time ceremony for all circuits up to size N

Generate: [G, τG, τ²G, ..., τᴺG]

Any circuit with ≤ N constraints can use this setup
No need for circuit-specific ceremony!
```

**Updatable:**
```
Anyone can add randomness later:
[G, τG, τ²G, ...] → [G, τ'G, τ'²G, ...]

Where τ' = τ · r (r is new randomness)

Improves security over time
```

### Custom Gates

**Groth16 Gates:**
```
Only: a * b = c
Need many constraints for complex operations
```

**PLONK Gates:**
```
General form:
q_L·a + q_R·b + q_O·c + q_M·a·b + q_C = 0

Can express:
- Addition: a + b = c
- Multiplication: a * b = c
- Linear combinations: 2a + 3b - c = 5
- Custom gates: Define your own!
```

**Example: Range Check Gate:**
```
Prove a ∈ [0, 2⁸)

Custom gate:
a = a₀ + 2a₁ + 4a₂ + ... + 128a₇
where each a_i ∈ {0, 1}

Single gate instead of 8 separate constraints!
```

### Proof Structure

**PLONK Proof:**
```
Commitments to wire polynomials: a(X), b(X), c(X)
Commitments to permutation polynomials: z(X)
Commitment to quotient polynomial: t(X)
Opening proofs: π_a, π_b, π_c, π_z, π_t

Total: ~10 group elements (~400 bytes)
```

**Verification:**
```
Check polynomial identities using KZG commitments
Verify opening proofs
~5 pairings + multi-exponentiations
~20-30ms verification time
```

## Comparison of zk-SNARK Schemes

| Feature | Groth16 | PLONK | Marlin |
|---------|---------|-------|--------|
| Proof Size | 192 bytes | ~400 bytes | ~600 bytes |
| Verification | ~10ms | ~20ms | ~30ms |
| Setup | Trusted, circuit-specific | Universal, updatable | Universal |
| Prover Time | Fast | Medium | Medium |
| Custom Gates | No | Yes | Yes |
| Maturity | Very mature | Mature | Newer |

## Practical Considerations

### Circuit Design

**Optimization Goals:**
```
1. Minimize constraints (faster proving)
2. Minimize public inputs (smaller proofs)
3. Use efficient operations (avoid expensive ops)
```

**Expensive Operations:**
```
Hash functions:
- SHA-256: ~25,000 constraints
- Poseidon: ~150 constraints
- Use ZK-friendly hashes!

Signature verification:
- ECDSA: ~150,000 constraints
- EdDSA: ~2,000 constraints
- Schnorr: ~1,000 constraints

Bit operations:
- AND, OR, XOR: Many constraints
- Use field arithmetic when possible
```

**Example: Merkle Tree Verification:**
```
Naive (SHA-256):
- Depth 20 tree
- 20 hashes
- 20 × 25,000 = 500,000 constraints

Optimized (Poseidon):
- Same tree
- 20 hashes
- 20 × 150 = 3,000 constraints

167x improvement!
```

### Proving Time

**Factors:**
```
1. Number of constraints
2. Circuit complexity
3. Hardware (CPU, RAM, GPU)
4. Implementation quality
```

**Benchmarks:**
```
1M constraints:
- CPU (32 cores): ~30 seconds
- GPU (RTX 3090): ~5 seconds

10M constraints:
- CPU: ~5 minutes
- GPU: ~30 seconds

100M constraints:
- CPU: ~1 hour
- GPU: ~5 minutes
```

**Hardware Requirements:**
```
Small circuits (< 1M constraints):
- CPU: 8+ cores
- RAM: 16 GB
- Time: Seconds

Medium circuits (1-10M constraints):
- CPU: 32+ cores
- RAM: 64 GB
- Time: Minutes

Large circuits (> 10M constraints):
- CPU: 64+ cores or GPU
- RAM: 128+ GB
- Time: Hours
```

### Security Considerations

**Trusted Setup Risks:**
```
If toxic waste is compromised:
- Can create fake proofs
- Undetectable forgery
- Complete system break

Mitigation:
- Multi-party computation
- Many participants (1000+)
- Transparent process
- Hardware destruction
```

**Implementation Bugs:**
```
Common issues:
- Underconstrained circuits
- Missing range checks
- Incorrect witness generation
- Soundness bugs

Prevention:
- Formal verification
- Extensive testing
- Security audits
- Fuzzing
```

**Quantum Vulnerability:**
```
zk-SNARKs rely on:
- Elliptic curve pairings
- Discrete logarithm problem

Quantum computers can break these:
- Shor's algorithm
- Timeline: 10-20 years?

Alternative: zk-STARKs (quantum-resistant)
```

## Applications

### 1. Private Transactions (Zcash)

**Goal:** Hide sender, receiver, and amount

**Circuit:**
```
Inputs:
- Old note (value, owner, nullifier)
- New note (value, owner)
- Merkle proof (old note in tree)

Constraints:
- Old note is in Merkle tree
- Nullifier is correct
- Values balance
- Owner has spending key

Public:
- Nullifier (prevents double-spend)
- Merkle root
- New note commitment

Private:
- Values
- Owners
- Spending keys
```

### 2. Scalability (zkSync)

**Goal:** Batch many transactions, verify with one proof

**Circuit:**
```
Inputs:
- Old state root
- Transactions (1000+)
- New state root

Constraints:
- Each transaction is valid
- Signatures verify
- Balances update correctly
- State transitions are correct

Public:
- Old state root
- New state root
- Transaction count

Private:
- Individual transactions
- Account details
```

### 3. Identity (Proof of Humanity)

**Goal:** Prove unique human without revealing identity

**Circuit:**
```
Inputs:
- Biometric hash
- Merkle proof (in registry)
- Nullifier

Constraints:
- Biometric in registry
- Nullifier derived correctly
- Not used before

Public:
- Nullifier
- Registry root

Private:
- Biometric data
- Identity
```

## Development Tools

### Circom

**Circuit Language:**
```circom
pragma circom 2.0.0;

template Multiplier() {
    signal input a;
    signal input b;
    signal output c;
    
    c <== a * b;
}

template Main() {
    signal input x;
    signal input y;
    signal output z;
    
    component mult = Multiplier();
    mult.a <== x;
    mult.b <== y;
    z <== mult.c;
}

component main = Main();
```

**Compilation:**
```bash
# Compile circuit
circom circuit.circom --r1cs --wasm --sym

# Generate witness
node generate_witness.js circuit.wasm input.json witness.wtns

# Trusted setup (Groth16)
snarkjs groth16 setup circuit.r1cs pot12_final.ptau circuit_0000.zkey

# Generate proof
snarkjs groth16 prove circuit_final.zkey witness.wtns proof.json public.json

# Verify proof
snarkjs groth16 verify verification_key.json public.json proof.json
```

### gnark (Go)

```go
package main

import (
    "github.com/consensys/gnark/frontend"
    "github.com/consensys/gnark/backend/groth16"
)

type Circuit struct {
    X frontend.Variable `gnark:"x"`
    Y frontend.Variable `gnark:"y"`
    Z frontend.Variable `gnark:",public"`
}

func (circuit *Circuit) Define(api frontend.API) error {
    api.AssertIsEqual(circuit.Z, api.Mul(circuit.X, circuit.Y))
    return nil
}

func main() {
    var circuit Circuit
    
    // Compile
    ccs, _ := frontend.Compile(ecc.BN254, r1cs.NewBuilder, &circuit)
    
    // Setup
    pk, vk, _ := groth16.Setup(ccs)
    
    // Prove
    witness := Circuit{X: 3, Y: 5, Z: 15}
    proof, _ := groth16.Prove(ccs, pk, witness)
    
    // Verify
    publicWitness := Circuit{Z: 15}
    groth16.Verify(proof, vk, publicWitness)
}
```

## Conclusion

zk-SNARKs are powerful cryptographic tools that enable succinct proofs of arbitrary computations. While they require trusted setups and are vulnerable to quantum computers, their small proof sizes and fast verification make them ideal for blockchain applications. Understanding the pipeline from computation to proof, the trade-offs between different schemes, and practical considerations for circuit design is essential for building zk-SNARK applications.

---

*Next: zk-STARKs*
